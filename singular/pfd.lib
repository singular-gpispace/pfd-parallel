////////////////////////////////////////////////////////////////////
version="version pfd.lib 4.1.3.2 Feb_2022 ";
category="??";
info="
LIBRARY: pfd.lib Multivariate Partial Fraction Decomposition

AUTHOR: Marcel Wittmann, e-mail: mwittman@mathematik.uni-kl.de

OVERVIEW:
This Library implements an algorithm based on the work of E. K. Leinartas to
write rational functions in mutiple variables as a sum of functions with
\"smaller\" numerators and denominators.
This can be used to shorten the IBP reduction coeffcients of multi-loop Feynman
integrals. For this application,
we also provide a procedure that applies the algorithm to all entries of a
matrix of rational functions given as one (possibly very big) txt-file.
If you use the library pfd.lib, please cite the corresponding paper
[J. Boehm, M. Wittmann, Z. Wu, Y. Xu, Y. Zhang: 'IBP reduction coefficients
made simple'] (preprint 2020).

KEYWORDS: partial fraction; decomposition; Leinartas

PROCEDURES:
  leinartas_adapted();                  calculate a partial fraction decomposition
                          of a rational function
  checkpfd();             test if a decomposition is equal to a rational
                          function given by numerator/denominator polynomials
  evaluatepfd();          substitute values in a partial fraction
                          decomposition gotten from @code{pfd}
  displaypfd();           print a decomposition gotten as output of @code{pfd}
  displaypfd_long();      like @code{display}, but denominators are written out
  getStringpfd();         turn a decomposition gotten from @code{pfd} into one
                          string
  getStringpfd_indexed(); like @code{getStringpfd}, but writes the denominator
                          factors just as @code{q1}, @code{q2}, ...
  readInputTXT();         read a matrix of rational functions from a txt-file
  pfdMat();               apply @code{pfd} to a matrix of rational functions
                          in parallel (using @ref{parallel_lib}) and save result
                          as easy-to-read txt-files.
  checkpfdMat();          test output files of @code{pfdMat} for correctness
";
/////////////////////////////////////////////////////////////////////////////

/*
LIB "random.lib";
LIB "ring.lib";
LIB "parallel.lib";
LIB "elim.lib";
//LIB "polylib.lib";
//LIB "poly.lib";
LIB "general.lib";
LIB "matrix.lib";
LIB "polylib.lib";
//LIB "dmodapp.lib"
*/

/////////////////////////////////////////////////////////////////////////////

static proc mod_init()
{
  LIB "random.lib";
  LIB "ring.lib";
  LIB "parallel.lib";
  LIB "elim.lib";
  LIB "polylib.lib";
//LIB "poly.lib";
  LIB "general.lib";
  LIB "matrix.lib";
//LIB "polylib.lib";
//LIB "dmodapp.lib"

  printlevel = 2;
  system("--ticks-per-sec",1000);

  // export some static functions so they can be run in parallel using parallelWaitAll:
  if (!defined(Tasks)) {LIB "tasks.lib";}

  exportto(Tasks,pfdWrap);
  importfrom(Tasks,pfdWrap);
  exportto(Pfd,pfdWrap);

  exportto(Tasks,testEntry);
  importfrom(Tasks,testEntry);
  exportto(Pfd,testEntry);

  exportto(Tasks,NSSdecompStep);
  importfrom(Tasks,NSSdecompStep);
  exportto(Pfd,NSSdecompStep);

  exportto(Tasks,shortNumeratorDecompStep);
  importfrom(Tasks,shortNumeratorDecompStep);
  exportto(Pfd,shortNumeratorDecompStep);

  exportto(Tasks,algDependDecompStep);
  importfrom(Tasks,algDependDecompStep);
  exportto(Pfd,algDependDecompStep);

  exportto(Tasks,numeratorDecompStep);
  importfrom(Tasks,numeratorDecompStep);
  exportto(Pfd,numeratorDecompStep);
}

// partial fractioning algorithm ///////////////////////////////////////////////

proc pfdParallel(list #)
"USAGE:   pfdParallel(f,g[,debug,steps,save_int_res]);   f,g poly, debug int, steps intvec, save_int_res int
          pfdParallel(f,g[,debug,steps,save_int_res]);   f poly, g list, debug int, steps intvec, save_int_res int
RETURN:   a partial fraction decomposition of f/g. Input and output have the
          same form as for @ref{pfd} but here the algorithm is parallelized
          using parallelWaitAll from @ref{tasks.lib}.
SEE ALSO: pfd, checkpfd, evaluatepfd, displaypfd, displaypfd_long, pfdMat
EXAMPLE:  example pfdParallel; shows an example"
{
  short = 0;
  int i,imax;
  int counter,tt,ttt;
  int t1=0;
  int t2=0;
  int t3=0;
  int t4=0;
  int t5=0;
  string dtime = datetime();
  for(i=0;i<=size(date);i++)
    {if(dtime[i]==":") {dtime[i]="-";}}

  i=0;
  if(size(#)>1)
  {
    if(typeof(#[1])=="ideal" && typeof(#[2])=="list") {# = list(#); i=1;}
    if(typeof(#[1])=="list")
      {if(size(#[1])==2)
        {if(typeof(#[1][1])=="ideal" && typeof(#[1][2])=="list") {i=1;} }}
  }
  if(i) // input of form pfdParallel(list(q,terms)[,debug])
  {
    int debug=0; int save_int_res=0;
    link l=":w "; link l1=":w "; link l2=":w "; link l3=":w "; link l4=":w ";
    intvec steps = 1,1,1,1;
    if(size(#)>1)
    {
      debug=#[2];
      l=":a "+string(debug)+"_log_"+dtime+".txt";
      system("--ticks-per-sec",1000);
    }
    if(size(#)>2)
    {
      steps=#[3];
    }
    if(size(#)>3)
    {
      save_int_res=#[4];
      if(steps[1]) {l1="ssi:w "+string(save_int_res)+"_result_after_step_1.ssi";}
      if(steps[2]) {l2="ssi:w "+string(save_int_res)+"_result_after_step_2.ssi";}
      if(steps[3]) {l3="ssi:w "+string(save_int_res)+"_result_after_step_3.ssi";}
      if(steps[4]) {l4="ssi:w "+string(save_int_res)+"_result_after_step_4.ssi";}
    }
    if(size(#)>4) {ERROR("wrong number of arguments, expected 1,2,3 or 4");}

    if(debug)
    {
      fprintf(l,"debug: %s", debug);
    }

    ideal q = #[1][1];
    list dec = mergepfd(list(), #[1][2]);
    int m = size(q);

    if(size(dec)==1 && dec[1][1]==0) // just one term and its numerator is 0
    {
      dec = list(ideal(),list(list(poly(0),intvec(0:0),intvec(0:0))));
      if(debug)
        {fprintf(l,"%ntotal: 0 ms (numerator was 0)",0); close(l);}
      if(save_int_res)
      {
        if(steps[1]) {write(l1,dec);}
        if(steps[2]) {write(l2,dec);}
        if(steps[3]) {write(l3,dec);}
        if(steps[4]) {write(l4,dec);}
      }
      if(voice<=printlevel) {displaypfd(dec);}
      return(dec);
    }
  }
  else
  {
    if(typeof(#[1])=="list") // input of form pfdParallel(arguments[, parallelize])
    {
      if(size(#)>1)
      {
        if(typeof(#[2])=="list")
          {list arguments = #;    int parallelize = 1;}
        else{if(typeof(#[2])=="int")
          {list arguments = #[1]; int parallelize = #[2];}
        else {ERROR("wrong type for second argument, expected int");}}
      }
      else // #=list(list(..))
      {
        return(list(pfdParallel(#[1])));
      }
      if(parallelize)
      {
        for(i=1; i<=size(arguments); i++)
        {
          if(typeof(arguments[i][1])=="list") //input is list of lists
            {arguments[i] = list(arguments[i],1);}
        }
        return(parallelWaitAll("pfdParallel",arguments));
      }
      else
      {
        list results;
        for(i=1; i<=size(arguments); i++)
        {
          if(typeof(arguments[i][1])=="list") //input is list of lists
            {results[i] = pfdParallel(arguments[i],0);}
          else
          {
            if(size(arguments[i])==2)
              {results[i] = pfdParallel(arguments[i][1],arguments[i][2]);}
            else{if(size(arguments[i])==3)
              {results[i] = pfdParallel(arguments[i][1],arguments[i][2],arguments[i][3]);}
            else {ERROR("wrong number of arguments, expected 2 or 3");}}
          }
        }
        return(results);
      }
    }

    poly f = #[1];
    if(typeof(#[2])=="list")
    {
      list g=#[2];
    }
    else
    {
      poly g=#[2];
    }

    int debug=0; int save_int_res=0;
    link l=":w "; link l1=":w "; link l2=":w "; link l3=":w "; link l4=":w ";
    intvec steps = 1,1,1,1;
    if(size(#)>2)
    {
      debug=#[3];
      l=":a "+string(debug)+"_log_"+dtime+".txt";
      system("--ticks-per-sec",1000);
    }
    if(size(#)>3)
    {
      steps=#[4];
    }
    if(size(#)>4)
    {
      save_int_res=#[5];
      if(steps[1]) {l1="ssi:w "+string(save_int_res)+"_result_after_step_1.ssi";}
      if(steps[2]) {l2="ssi:w "+string(save_int_res)+"_result_after_step_2.ssi";}
      if(steps[3]) {l3="ssi:w "+string(save_int_res)+"_result_after_step_3.ssi";}
      if(steps[4]) {l4="ssi:w "+string(save_int_res)+"_result_after_step_4.ssi";}
    }
    if(size(#)>5) {ERROR("wrong number of arguments, expected 2,3,4 or 5");}

    if(debug)
    {
      fprintf(l,"debug: %s", debug);
      fprintf(l,"size(string(f)) = %s, size(string(g)) = %s %n",
                 size(string(f)), size(string(g)), 0);
    }

    if(f==0)
    {
      list dec = list(ideal(),list(list(poly(0),intvec(0:0),intvec(0:0))));
      if(debug)
        {fprintf(l,"%ntotal: 0 ms (numerator was 0)",0); close(l);}
      if(save_int_res)
      {
        if(steps[1]) {write(l1,dec);}
        if(steps[2]) {write(l2,dec);}
        if(steps[3]) {write(l3,dec);}
        if(steps[4]) {write(l4,dec);}
      }
      if(voice<=printlevel) {displaypfd(dec);}
      return(dec);
    }
    if(typeof(g)=="poly")
    {
      if(deg(g)==0)
      {
        list dec = list(ideal(),list(list(f/g,intvec(0:0),intvec(0:0))));
        if(debug)
          {fprintf(l,"%ntotal: 0 ms (denominator was constant)",0); close(l);}
        if(save_int_res)
        {
          if(steps[1]) {write(l1,dec);}
          if(steps[2]) {write(l2,dec);}
          if(steps[3]) {write(l3,dec);}
          if(steps[4]) {write(l4,dec);}
        }
        if(voice<=printlevel) {displaypfd(dec);}
        return(dec);
      }

      // (1) factorization of the denominator ////////////////////////////////////
      if(debug) {t1 = rtimer; write(l,"factorizing ");}
      list factor = factorize(g);
      number lcoeff;
      for(i=2; i<=size(factor[1]); i++)
      {
        lcoeff = leadcoef(factor[1][i]);
        factor[1][i] = factor[1][i]/lcoeff;
        factor[1][1] = factor[1][1]*(lcoeff^factor[2][i]); // polynomial is monic (thus unique)
        lcoeff = content(factor[1][i]);
        factor[1][i] = factor[1][i]/lcoeff;
        factor[1][1] = factor[1][1]*(lcoeff^factor[2][i]); // polynomial has nice coefficients
      }
      ideal q = factor[1];
      f = f/q[1];
      q=delete(q,1);
      intvec e = factor[2]; e=delete(e,1);
      int m = size(q);
      if(debug) {t1 = rtimer-t1; fprintf(l,"done! (%s ms)", t1);}
    }
    else{if(typeof(g)=="list")
    {
      if(size(g[1])==0)
      {
        list dec = list(ideal(),list(list(f,intvec(0:0),intvec(0:0))));
        if(debug)
          {fprintf(l,"%ntotal: 0 ms (denominator was constant)",0); close(l);}
        if(save_int_res)
        {
          if(steps[1]) {write(l1,dec);}
          if(steps[2]) {write(l2,dec);}
          if(steps[3]) {write(l3,dec);}
          if(steps[4]) {write(l4,dec);}
        }
        if(voice<=printlevel) {displaypfd(dec);}
        return(dec);
      }

      // denominator is already factorized
      for(i=1;i<=size(g[1]);i++)
      {
        if(size(factorize(g[1][i])[1])>2)
          {ERROR("factors should be irreducible");}
      }

      ideal q = g[1];
      intvec e = g[2];
      int m = size(q);
    }
    else
    {ERROR("wrong type for second argument, expected poly or list(ideal,intvec)");}}

    list dec = list(list(poly(f),1..m,e));
  }

  list terms,newterms,results,arguments;


  // (2) Nullstellensatz decomposition /////////////////////////////////////////
  if(steps[1])
  {
    if(debug)
      {t2 = rtimer; write(l,"Nullstellensatz decomposition ");}
    terms = dec;
    dec = list();
    while(size(terms)>0)
    {
      if(debug) {ttt = rtimer; counter++;}
      imax = size(terms);
      newterms = list();
      for(i=1; i<=imax; i++)
        {arguments[i] = list(terms[i],q);}

      results = parallelWaitAll("NSSdecompStep",arguments);

      for(i=1; i<=imax; i++)
      {
        if(size(results[i])>1) {newterms = mergepfd(newterms, results[i]);}
        else                        {dec = mergepfd(dec,      results[i]);}
      }
      terms = newterms;
      arguments = list();
      results = list();
      if(debug)
        {fprintf(l,"  %s: %s ms, %s terms, %s unfinished",
         counter, rtimer-ttt, size(terms)+size(dec), size(terms));}
    }

    if(debug)
      {t2 = rtimer-t2; fprintf(l,"done! (%s ms, %s terms)", t2, size(dec));}

    if(save_int_res)
    {
      write(l1,list(q,dec));
    }
  }
  else
  {
    if(debug)
      {write(l,"skipping Nullstellensatz decomposition");}
  }


  // (3) short numerator decomposition /////////////////////////////////////////
  if(steps[2])
  {
    if(debug)
      {t3 = rtimer; write(l,"short numerator decompositions "); counter=0;}
    terms = dec;
    dec = list();
    while(size(terms)>0)
    {
      if(debug) {tt = rtimer; counter++;}
      imax = size(terms);
      newterms = list();
      for(i=1; i<=imax; i++)
        {arguments[i] = list(terms[i],q,debug,l);}

      results = parallelWaitAll("shortNumeratorDecompStep",arguments);

      for(i=1; i<=imax; i++)
      {
        if(debug) {ttt = rtimer;}
        newterms = mergepfd(newterms, results[i][1]);
        dec = mergepfd(dec, results[i][2]);
        if(debug)
          {fprintf(l,"      merging: %s ms, %s new terms",
           rtimer-ttt, size(results[i][1]));}
      }
      terms = newterms;
      arguments = list();
      results = list();
      if(debug)
        {fprintf(l,"  %s: %s ms, %s terms, %s unfinished",
         counter, rtimer-tt, size(terms)+size(dec), size(terms));}
    }

    if(debug)
      {t3 = rtimer-t3; fprintf(l,"done! (%s ms, %s terms)", t3, size(dec));}

    if(save_int_res)
    {
      write(l2,list(q,dec));
    }
  }
  else
  {
    if(debug)
      {write(l,"skipping numerator decomposition");}
  }

  // (4) algebraic dependence decomposition ////////////////////////////////////
  if(steps[3])
  {
    if(debug)
      {t4 = rtimer; write(l,"algebraic dependence decomposition "); counter=0;}
    terms = dec;
    dec = list();
    while(size(terms)>0)
    {
      if(debug) {tt = rtimer; counter++;}
      imax = size(terms);
      newterms = list();
      for(i=1; i<=imax; i++)
        {arguments[i] = list(terms[i],q,debug,l);}

      results = parallelWaitAll("algDependDecompStep",arguments);

      for(i=1; i<=imax; i++)
      {
        if(debug) {ttt = rtimer;}
        if(size(results[i])>1) {newterms = mergepfd(newterms, results[i]);}
        else                    {dec = mergepfd(dec,      results[i]);}
        if(debug)
          {fprintf(l,"      merging: %s ms, %s new terms", rtimer-ttt, size(results[i]));}
      }
      terms = newterms;
      arguments = list();
      results = list();
      if(debug)
        {fprintf(l,"  %s: %s ms, %s terms, %s unfinished",
         counter, rtimer-tt, size(terms)+size(dec),size(terms));}
    }

    if(debug)
      {t4 = rtimer-t4; fprintf(l,"done! (%s ms, %s terms)", t4, size(dec));}

    if(save_int_res)
    {
      write(l3,list(q,dec));
    }
  }
  else
  {
    if(debug)
      {write(l,"skipping algebraic dependence decomposition");}
  }

  // (5) numerator decomposition ///////////////////////////////////////////////
  if(steps[4])
  {
    if(debug)
      {t5 = rtimer; write(l,"numerator decompositions "); counter=0;}
    terms = dec;
    dec = list();
    while(size(terms)>0)
    {
      if(debug) {tt = rtimer; counter++;}
      imax = size(terms);
      newterms = list();
      for(i=1; i<=imax; i++)
      {arguments[i] = list(terms[i],q,debug,l);}

      results = parallelWaitAll("numeratorDecompStep",arguments);

      for(i=1; i<=imax; i++)
      {
        if(debug) {ttt = rtimer;}
        newterms = mergepfd(newterms, results[i][1]);
        dec = mergepfd(dec, results[i][2]);
        if(debug)
          {fprintf(l,"      merging: %s ms, %s new terms", rtimer-ttt, size(results[i][1]));}
      }
      terms = newterms;
      arguments = list();
      results = list();
      if(debug)
        {fprintf(l,"  %s: %s ms, %s terms, %s unfinished",
         counter, rtimer-tt, size(terms)+size(dec), size(terms));}
    }
    if(debug)
      {t5 = rtimer-t5; fprintf(l,"done! (%s ms, %s terms)", t5, size(dec));}

    if(save_int_res)
    {
      write(l4,list(q,dec));
    }
  }
  else
  {
    if(debug)
      {write(l,"skipping numerator decomposition");}
  }


  if(size(dec)==1) {if(dec[1][1]==0) {dec = list();}}
  dec = list(q,dec);
  if(debug) {fprintf(l,"%ntotal: %s ms", t1+t2+t3+t4+t5); close(l);}
  if(voice<=printlevel) {displaypfd(dec);}
  return(dec);
}
example
{
  "EXAMPLE:";
  echo=voice;
  ring R = 0,(x,y),dp;
  poly f = x^3+3*x^2*y+2*y^2-x^2+4*x*y;
  poly g = x^2*y*(x-1)*(x-y)^2;

  list dec = pfdParallel(f,g);

  displaypfd_long(dec);   // display result
  checkpfd(list(f,g),dec);   // check for equality to f/g

  // a more complicated example
  ring S = 0,(s12,s15,s23,s34,s45),dp;
  poly f = 7*s12^4*s15^2 + 11*s12^3*s15^3 + 4*s12^2*s15^4 - 10*s12^4*s15*s23
    - 14*s12^3*s15^2*s23 - 4*s12^2*s15^3*s23 + 3*s12^4*s23^2 + 3*s12^3*s15*s23^2
    + 13*s12^4*s15*s34 + 12*s12^3*s15^2*s34 + 2*s12^2*s15^3*s34
    - 5*s12^4*s23*s34 + 33*s12^3*s15*s23*s34 + 49*s12^2*s15^2*s23*s34
    + 17*s12*s15^3*s23*s34 - 17*s12^3*s23^2*s34 - 19*s12^2*s15*s23^2*s34
    - 5*s12*s15^2*s23^2*s34 - 24*s12^3*s15*s34^2 - 15*s12^2*s15^2*s34^2
    + 2*s12*s15^3*s34^2 + 15*s12^3*s23*s34^2 - 34*s12^2*s15*s23*s34^2
    - 31*s12*s15^2*s23*s34^2 + 2*s15^3*s23*s34^2 + 33*s12^2*s23^2*s34^2
    + 29*s12*s15*s23^2*s34^2 + 5*s15^2*s23^2*s34^2 + 9*s12^2*s15*s34^3
    - 4*s12*s15^2*s34^3 - 15*s12^2*s23*s34^3 + 9*s12*s15*s23*s34^3
    - 4*s15^2*s23*s34^3 - 27*s12*s23^2*s34^3 - 13*s15*s23^2*s34^3
    + 2*s12*s15*s34^4 + 5*s12*s23*s34^4 + 2*s15*s23*s34^4 + 8*s23^2*s34^4
    - 6*s12^3*s15^2*s45 - 9*s12^2*s15^3*s45 - 2*s12*s15^4*s45
    + 30*s12^3*s15*s23*s45 + 56*s12^2*s15^2*s23*s45 + 24*s12*s15^3*s23*s45
    - 12*s12^3*s23^2*s45 - 23*s12^2*s15*s23^2*s45 - 10*s12*s15^2*s23^2*s45
    - 30*s12^3*s15*s34*s45 - 32*s12^2*s15^2*s34*s45 - 6*s12*s15^3*s34*s45
    + 7*s12^3*s23*s34*s45 - 86*s12^2*s15*s23*s34*s45 - 104*s12*s15^2*s23*s34*s45
    - 15*s15^3*s23*s34*s45 + 41*s12^2*s23^2*s34*s45 + 51*s12*s15*s23^2*s34*s45
    + 10*s15^2*s23^2*s34*s45 - 5*s12^3*s34^2*s45 + 33*s12^2*s15*s34^2*s45
    + 14*s12*s15^2*s34^2*s45 - 2*s15^3*s34^2*s45 - 21*s12^2*s23*s34^2*s45
    + 62*s12*s15*s23*s34^2*s45 + 28*s15^2*s23*s34^2*s45 - 46*s12*s23^2*s34^2*s45
    - 28*s15*s23^2*s34^2*s45 + 10*s12^2*s34^3*s45 - s12*s15*s34^3*s45
    + 4*s15^2*s34^3*s45 + 21*s12*s23*s34^3*s45 - 6*s15*s23*s34^3*s45
    + 17*s23^2*s34^3*s45 - 5*s12*s34^4*s45 - 2*s15*s34^4*s45 - 7*s23*s34^4*s45
    - 6*s12^2*s15^2*s45^2 - 5*s12*s15^3*s45^2 - 2*s15^4*s45^2
    - 28*s12^2*s15*s23*s45^2 - 42*s12*s15^2*s23*s45^2 - 10*s15^3*s23*s45^2
    + 9*s12^2*s23^2*s45^2 + 10*s12*s15*s23^2*s45^2 + 24*s12^2*s15*s34*s45^2
    + 36*s12*s15^2*s34*s45^2 + 10*s15^3*s34*s45^2 - 11*s12^2*s23*s34*s45^2
    + 31*s12*s15*s23*s34*s45^2 + 25*s15^2*s23*s34*s45^2
    - 18*s12*s23^2*s34*s45^2 - 10*s15*s23^2*s34*s45^2 + 4*s12^2*s34^2*s45^2
    - 29*s12*s15*s34^2*s45^2 - 17*s15^2*s34^2*s45^2 + 27*s12*s23*s34^2*s45^2
    + 2*s15*s23*s34^2*s45^2 + 9*s23^2*s34^2*s45^2 - 3*s12*s34^3*s45^2
    + 10*s15*s34^3*s45^2 - 16*s23*s34^3*s45^2 - s34^4*s45^2 + 6*s12*s15^2*s45^3
    + 3*s15^3*s45^3 + 8*s12*s15*s23*s45^3 + 10*s15^2*s23*s45^3
    - 8*s12*s15*s34*s45^3 - 10*s15^2*s34*s45^3 + 9*s12*s23*s34*s45^3
    + s12*s34^2*s45^3 + 8*s15*s34^2*s45^3 - 9*s23*s34^2*s45^3 - s34^3*s45^3
    - s15^2*s45^4 + s15*s34*s45^4;
  poly g = 4*s12*s15*(s12 + s15 - s34)*(s15 - s23 - s34)*(s12 + s23 - s45)
                                 *(s12 - s34 - s45)*(s12 + s15 - s34 - s45)*s45;

  list dec = pfdParallel(f,g);

  displaypfd(dec);
  checkpfd(list(f,g),dec);

  // size comparison:
  size(string(f)) + size(string(g));
  size(getStringpfd(dec));
}

proc leinartas_adapted(list #)
"USAGE:   leinartas_adapted(f,g[,debug,steps,save_int_res]);   f,g poly, debug int, steps intvec, save_int_res int
          leinartas_adapted(f,g[,debug,steps,save_int_res]);   f poly, g list(ideal,intvec), debug int, steps intvec, save_int_res int
          leinartas_adapted(f,g[,debug,steps,save_int_res]);   f poly, g list(poly,ideal), debug int, steps intvec, save_int_res int
          leinartas_adapted(list(q,terms)[,debug,steps,save_int_res])  q ideal, terms list, debug int, steps intvec, save_int_res int
          leinartas_adapted(arguments[, parallelize]);     arguments list, parallelize int
RETURN:   a partial fraction decomposition of f/g as a list @code{l} where
          @code{l[1]} is an ideal generated by irreducible polynomials and
          @code{l[2]} is a list of fractions.
          Each fraction is represented by a list of
       @* 1) the numerator polynomial
       @* 2) an intvec of indices @code{i} for which @code{l[1][i]} occurs
             as a factor in the denominator
       @* 3) an intvec containing the exponents of those irreducible factors.
       @* Setting @code{debug} to a positive integer measures runtimes and
          creates a log file (default: @code{debug=0}).
       @* With an intvec @code{steps} of length four you can skip individual
          steps of the algorithm, e.g. (1,1,0,1) to skip the third step
          (algebraic dependence decomposition).
       @* If @code{save_int_res} is set to a positive integer (default: 0), the
          intermediate result will be saved after each step in a separate
          .ssi-file in the same format as the output of leinartas_adapted.
       @* The denominator g can also be given in factorized form as a list of
          an ideal of irreducible non constant polynomials and an intvec of
          exponents. This can save time since the first step in the algorithm is
          to factorize g. (A list of the zero-ideal and an empty intvec
          represents a denominator of 1.)
       @* In case not all factors and exponents are known, the denominator can
          also be given as a list of the denominator polynomial and an ideal of
          possible factors which do not even have to be irreducible. But if the
          denominator is divisible by some of the given factors, this will speed
          up the factorization algorithm.
       @* Instead of f and g, the input can be given in the same format as the
          output of @code{leinartas_adapted}, i.e. a list of an ideal of denominator factors
          and a list of terms as described above.
       @* If the input is a single list (or even a list of
          lists) containing elements of the form @code{list(f,g[,debug])}
          (@code{f,g,debug} as above), the algorithm is applied to all entries
          in parallel (using @ref{parallel_lib}), if @code{parallelize=1}
          (default) and in sequence if @code{parallelize=0}. A list (or list of
          lists) of the results is returned.
NOTE:     The result depends on the monomial ordering. For \"small\" results
          use @code{dp}.
SEE ALSO: checkpfd, evaluatepfd, displaypfd, displaypfd_long, pfdMat
EXAMPLE:  example leinartas_adapted; shows an example"
{
  short = 0;
  int i,j,k,imax;
  int counter,tt,ttt;
  int t1=0;
  int t2=0;
  int t3=0;
  int t4=0;
  int t5=0;
  string dtime = datetime();
  for(i=0;i<=size(dtime);i++)
    {if(dtime[i]==":") {dtime[i]="-";}}

  i=0;
  if(size(#)>1)
  {
    if(typeof(#[1])=="ideal" && typeof(#[2])=="list") {# = list(#); i=1;}
    if(typeof(#[1])=="list")
      {if(size(#[1])==2)
        {if(typeof(#[1][1])=="ideal" && typeof(#[1][2])=="list") {i=1;} }}
  }

  if(i) // input of form leinartas_adapted(list(q,terms)[,debug])
  {
    int debug=0; int save_int_res=0;
    link l=":w "; link l1=":w "; link l2=":w "; link l3=":w "; link l4=":w ";
    intvec steps = 1,1,1,1;
    if(size(#)>1)
    {
      debug=#[2];
      l=":a "+string(debug)+"_log_"+dtime+".txt";
      system("--ticks-per-sec",1000);
    }
    if(size(#)>2)
    {
      steps=#[3];
    }
    if(size(#)>3)
    {
      save_int_res=#[4];
      if(steps[1]) {l1="ssi:w "+string(save_int_res)+"_result_after_step_1.ssi";}
      if(steps[2]) {l2="ssi:w "+string(save_int_res)+"_result_after_step_2.ssi";}
      if(steps[3]) {l3="ssi:w "+string(save_int_res)+"_result_after_step_3.ssi";}
      if(steps[4]) {l4="ssi:w "+string(save_int_res)+"_result_after_step_4.ssi";}
    }
    if(size(#)>4) {ERROR("wrong number of arguments, expected 1,2,3 or 4");}

    if(debug)
    {
      fprintf(l,"debug: %s", debug);
    }

    ideal q = #[1][1];
    list terms = mergepfd(list(), #[1][2]);
    int m = size(q);

    if(size(terms)==1 && terms[1][1]==0) // just one term and its numerator is 0
    {
      list dec = list(ideal(),list(list(poly(0),intvec(0:0),intvec(0:0))));
      if(debug)
        {fprintf(l,"%ntotal: 0 ms (numerator was 0)",0); close(l);}
      if(save_int_res)
      {
        if(steps[1]) {write(l1,dec);}
        if(steps[2]) {write(l2,dec);}
        if(steps[3]) {write(l3,dec);}
        if(steps[4]) {write(l4,dec);}
      }
      if(voice<=printlevel) {displaypfd(dec);}
      return(dec);
    }
  }
  else
  {
    if(typeof(#[1])=="list") // input of form leinartas_adapted(arguments[, parallelize])
    {
      if(size(#)>1)
      {
        if(typeof(#[2])=="list")
          {list arguments = #;    int parallelize = 1;}
        else{if(typeof(#[2])=="int")
          {list arguments = #[1]; int parallelize = #[2];}
        else {ERROR("wrong type for second argument, expected int");}}
      }
      else // #=list(list(..))
      {
        return(list(leinartas_adapted(#[1])));
      }
      if(parallelize)
      {
        for(i=1; i<=size(arguments); i++)
        {
          if(typeof(arguments[i][1])=="list") //input is list of lists
            {arguments[i] = list(arguments[i],1);}
        }
        return(parallelWaitAll("leinartas_adapted",arguments));
      }
      else
      {
        list results;
        for(i=1; i<=size(arguments); i++)
        {
          if(typeof(arguments[i][1])=="list") //input is list of lists
            {results[i] = leinartas_adapted(arguments[i],0);}
          else
          {
            if(size(arguments[i])==2)
              {results[i] = leinartas_adapted(arguments[i][1],arguments[i][2]);}
            else{if(size(arguments[i])==3)
              {results[i] = leinartas_adapted(arguments[i][1],arguments[i][2],arguments[i][3]);}
            else {ERROR("wrong number of arguments, expected 2 or 3");}}
          }
        }
        return(results);
      }
    }

    poly f = #[1];
    if(typeof(#[2])=="list")
    {
      list g=#[2];
    }
    else
    {
      poly g=#[2];
    }

    int debug=0; int save_int_res=0;
    link l=":w "; link l1=":w "; link l2=":w "; link l3=":w "; link l4=":w ";
    intvec steps = 1,1,1,1;
    if(size(#)>2)
    {
      debug=#[3];
      l=":a "+string(debug)+"_log_"+dtime+".txt";
      system("--ticks-per-sec",1000);
    }
    if(size(#)>3)
    {
      steps=#[4];
    }
    if(size(#)>4)
    {
      save_int_res=#[5];
      if(steps[1]) {l1="ssi:w "+string(save_int_res)+"_result_after_step_1.ssi";}
      if(steps[2]) {l2="ssi:w "+string(save_int_res)+"_result_after_step_2.ssi";}
      if(steps[3]) {l3="ssi:w "+string(save_int_res)+"_result_after_step_3.ssi";}
      if(steps[4]) {l4="ssi:w "+string(save_int_res)+"_result_after_step_4.ssi";}
    }
    if(size(#)>5) {ERROR("wrong number of arguments, expected 2,3,4 or 5");}

    if(debug)
    {
      fprintf(l,"debug: %s", debug);
      fprintf(l,"size(string(f)) = %s, size(string(g)) = %s %n",
                 size(string(f)), size(string(g)), 0);
    }

    // sort out some trivial cases
    if(f==0)
    {
      list dec = list(ideal(),list(list(poly(0),intvec(0:0),intvec(0:0))));
      if(debug)
        {fprintf(l,"%ntotal: 0 ms (numerator was 0)",0); close(l);}
      if(save_int_res)
      {
        if(steps[1]) {write(l1,dec);}
        if(steps[2]) {write(l2,dec);}
        if(steps[3]) {write(l3,dec);}
        if(steps[4]) {write(l4,dec);}
      }
      if(voice<=printlevel) {displaypfd(dec);}
      return(dec);
    }

    if(typeof(g)=="poly")
    {
      if(deg(g)==0)
      {
        list dec = list(ideal(),list(list(f/g,intvec(0:0),intvec(0:0))));
        if(debug)
          {fprintf(l,"%ntotal: 0 ms (denominator was constant)",0); close(l);}
        if(save_int_res)
        {
          if(steps[1]) {write(l1,dec);}
          if(steps[2]) {write(l2,dec);}
          if(steps[3]) {write(l3,dec);}
          if(steps[4]) {write(l4,dec);}
        }
        if(voice<=printlevel) {displaypfd(dec);}
        return(dec);
      }
    } else{if(typeof(g)=="list") {
      if(typeof(g[1])=="ideal" && typeof(g[2])=="intvec") {
        // ideal of irreducible factors & intvec of exponents
        if(size(g[1])==0) {
          list dec = list(ideal(),list(list(f,intvec(0:0),intvec(0:0))));
          if(debug)
            {fprintf(l,"%ntotal: 0 ms (denominator was constant)",0); close(l);}
          if(save_int_res)
          {
            if(steps[1]) {write(l1,dec);}
            if(steps[2]) {write(l2,dec);}
            if(steps[3]) {write(l3,dec);}
            if(steps[4]) {write(l4,dec);}
          }
          if(voice<=printlevel) {displaypfd(dec);}
          return(dec);
        }
      }
    }}

    // (1) factorization of the denominator ////////////////////////////////////
    list input;
    if (debug) {
      input, t1 = prepare_terms(f, g, debug, l);
    } else {
      input = prepare_terms(f, g, debug, l);
    }
    ideal q = input[1];
    list terms = input[2];
  }


  if (debug) {
    int t = rtimer;
    write(l, "Start PFD functional unit");
  }

  list dec;
  if (debug) {
    dec, t2, t3, t4, t5 = pfd_functional_unit(terms, q, steps, save_int_res, debug, l);
  } else {
    dec = pfd_functional_unit(terms, q, steps, save_int_res, debug, l);
  }

  //dec = list(q,dec); pfd_functional_unit already does this
  if(debug) {fprintf(l,"%ntotal: %s ms", t1+t2+t3+t4+t5); close(l);}
  if(voice<=printlevel) {displaypfd(dec);}
  return(dec);
}
example
{
  "EXAMPLE:";
  echo=voice;
  ring R = 0,(x,y),dp;
  poly f = x^3+3*x^2*y+2*y^2-x^2+4*x*y;
  poly g = x^2*y*(x-1)*(x-y)^2;

  list dec = leinartas_adapted(f,g);

  displaypfd_long(dec);   // display result
  checkpfd(list(f,g),dec);   // check for equality to f/g

  // calculate decompositions of a 2x2 matrix of rational functions at once:
  list arguments = list(list(f, g),          list(1, f)     ),
                        list(list(x*y, y+1), list(1, x^2-y^2));

  dec = leinartas_adapted(arguments);

  // the result has the same shape as the
  // input (2x2 matrix as list of lists):
  displaypfd_long(dec[1][1]);
  displaypfd_long(dec[1][2]);
  displaypfd_long(dec[2][1]);
  displaypfd_long(dec[2][2]);

  // a more complicated example
  ring S = 0,(s12,s15,s23,s34,s45),dp;
  poly f = 7*s12^4*s15^2 + 11*s12^3*s15^3 + 4*s12^2*s15^4 - 10*s12^4*s15*s23
    - 14*s12^3*s15^2*s23 - 4*s12^2*s15^3*s23 + 3*s12^4*s23^2 + 3*s12^3*s15*s23^2
    + 13*s12^4*s15*s34 + 12*s12^3*s15^2*s34 + 2*s12^2*s15^3*s34
    - 5*s12^4*s23*s34 + 33*s12^3*s15*s23*s34 + 49*s12^2*s15^2*s23*s34
    + 17*s12*s15^3*s23*s34 - 17*s12^3*s23^2*s34 - 19*s12^2*s15*s23^2*s34
    - 5*s12*s15^2*s23^2*s34 - 24*s12^3*s15*s34^2 - 15*s12^2*s15^2*s34^2
    + 2*s12*s15^3*s34^2 + 15*s12^3*s23*s34^2 - 34*s12^2*s15*s23*s34^2
    - 31*s12*s15^2*s23*s34^2 + 2*s15^3*s23*s34^2 + 33*s12^2*s23^2*s34^2
    + 29*s12*s15*s23^2*s34^2 + 5*s15^2*s23^2*s34^2 + 9*s12^2*s15*s34^3
    - 4*s12*s15^2*s34^3 - 15*s12^2*s23*s34^3 + 9*s12*s15*s23*s34^3
    - 4*s15^2*s23*s34^3 - 27*s12*s23^2*s34^3 - 13*s15*s23^2*s34^3
    + 2*s12*s15*s34^4 + 5*s12*s23*s34^4 + 2*s15*s23*s34^4 + 8*s23^2*s34^4
    - 6*s12^3*s15^2*s45 - 9*s12^2*s15^3*s45 - 2*s12*s15^4*s45
    + 30*s12^3*s15*s23*s45 + 56*s12^2*s15^2*s23*s45 + 24*s12*s15^3*s23*s45
    - 12*s12^3*s23^2*s45 - 23*s12^2*s15*s23^2*s45 - 10*s12*s15^2*s23^2*s45
    - 30*s12^3*s15*s34*s45 - 32*s12^2*s15^2*s34*s45 - 6*s12*s15^3*s34*s45
    + 7*s12^3*s23*s34*s45 - 86*s12^2*s15*s23*s34*s45 - 104*s12*s15^2*s23*s34*s45
    - 15*s15^3*s23*s34*s45 + 41*s12^2*s23^2*s34*s45 + 51*s12*s15*s23^2*s34*s45
    + 10*s15^2*s23^2*s34*s45 - 5*s12^3*s34^2*s45 + 33*s12^2*s15*s34^2*s45
    + 14*s12*s15^2*s34^2*s45 - 2*s15^3*s34^2*s45 - 21*s12^2*s23*s34^2*s45
    + 62*s12*s15*s23*s34^2*s45 + 28*s15^2*s23*s34^2*s45 - 46*s12*s23^2*s34^2*s45
    - 28*s15*s23^2*s34^2*s45 + 10*s12^2*s34^3*s45 - s12*s15*s34^3*s45
    + 4*s15^2*s34^3*s45 + 21*s12*s23*s34^3*s45 - 6*s15*s23*s34^3*s45
    + 17*s23^2*s34^3*s45 - 5*s12*s34^4*s45 - 2*s15*s34^4*s45 - 7*s23*s34^4*s45
    - 6*s12^2*s15^2*s45^2 - 5*s12*s15^3*s45^2 - 2*s15^4*s45^2
    - 28*s12^2*s15*s23*s45^2 - 42*s12*s15^2*s23*s45^2 - 10*s15^3*s23*s45^2
    + 9*s12^2*s23^2*s45^2 + 10*s12*s15*s23^2*s45^2 + 24*s12^2*s15*s34*s45^2
    + 36*s12*s15^2*s34*s45^2 + 10*s15^3*s34*s45^2 - 11*s12^2*s23*s34*s45^2
    + 31*s12*s15*s23*s34*s45^2 + 25*s15^2*s23*s34*s45^2
    - 18*s12*s23^2*s34*s45^2 - 10*s15*s23^2*s34*s45^2 + 4*s12^2*s34^2*s45^2
    - 29*s12*s15*s34^2*s45^2 - 17*s15^2*s34^2*s45^2 + 27*s12*s23*s34^2*s45^2
    + 2*s15*s23*s34^2*s45^2 + 9*s23^2*s34^2*s45^2 - 3*s12*s34^3*s45^2
    + 10*s15*s34^3*s45^2 - 16*s23*s34^3*s45^2 - s34^4*s45^2 + 6*s12*s15^2*s45^3
    + 3*s15^3*s45^3 + 8*s12*s15*s23*s45^3 + 10*s15^2*s23*s45^3
    - 8*s12*s15*s34*s45^3 - 10*s15^2*s34*s45^3 + 9*s12*s23*s34*s45^3
    + s12*s34^2*s45^3 + 8*s15*s34^2*s45^3 - 9*s23*s34^2*s45^3 - s34^3*s45^3
    - s15^2*s45^4 + s15*s34*s45^4;
  poly g = 4*s12*s15*(s12 + s15 - s34)*(s15 - s23 - s34)*(s12 + s23 - s45)
                                 *(s12 - s34 - s45)*(s12 + s15 - s34 - s45)*s45;

  list dec = leinartas_adapted(f,g);

  displaypfd(dec);
  checkpfd(list(f,g),dec);

  // size comparison:
  size(string(f)) + size(string(g));
  size(getStringpfd(dec));
}

proc prepare_terms(poly f, list #)
{
  if ((size(#) < 1) || (size(#) == 2) || (size(#) > 3)) {
    ERROR("incorrect call to prepare_terms: requires 2 or 4 arguments");
  }
  def g = #[1]
  if (size(#) == 3) {
    int debug = #[2];
    link l  = #[3];
  } else {
    int debug = -
    link l  = ":w ";
  }
  int t1;
  int i, j, k;


  if (typeof(g)=="poly") {
    // (1) factorization of the denominator //////////////////////////////////// 
    if(debug) {t1 = rtimer; write(l,"factorizing ");}
    list factor = factorize(g);
    number lcoeff;
    for(i=2; i<=size(factor[1]); i++) {
      lcoeff = leadcoef(factor[1][i]);
      factor[1][i] = factor[1][i]/lcoeff;
      factor[1][1] = factor[1][1]*(lcoeff^factor[2][i]); // polynomial is monic (thus unique)

      lcoeff = content(factor[1][i]);
      factor[1][i] = factor[1][i]/lcoeff;
      factor[1][1] = factor[1][1]*(lcoeff^factor[2][i]); // polynomial has nice coefficients
    }
    ideal q = factor[1];
    f = f/q[1];
    q=delete(q,1);
    intvec e = factor[2]; e=delete(e,1);
    int m = size(q);
    if(debug) {t1 = rtimer-t1; fprintf(l,"done! (%s ms)", t1);}

  } else{if (typeof(g)=="list") {
    if(typeof(g[1])=="ideal" && typeof(g[2])=="intvec") {
      // denominator is already factorized
      for(i=1;i<=size(g[1]);i++) {
        if(size(factorize(g[1][i])[1])>2) {
          ERROR("factors should be irreducible");
        }
      }
      ideal q = g[1];
      intvec e = g[2];
      int m = size(q);
      t1 = 0;

    } else{if(typeof(g[1])=="poly" && typeof(g[2])=="ideal") {
      // denominator polynomial & ideal of factors
      if(debug) {t1 = rtimer; write(l,"factorizing ");}
      ideal q,factors;
      intvec e,exponents=0:0,0:0;

      int expon;
      for(i=1; i<=size(g[2]); i++) {
        expon=0;
        while(reduce(g[1],g[2][i])==0) {
          g[1] = g[1]/g[2][i];
          expon++;
        }
        if(expon>0) {
          factors[size(factors)+1] = g[2][i];
          exponents[size(exponents)+1] = expon;
        }
      }

      if(deg(g[1])==0) {
        number constant = number(g[1]);
      } else {
        factors[size(factors)+1] = g[1];
        exponents[size(exponents)+1] = 1;
        number constant = number(1);
      }

      list fact;
      number lcoeff;
      for(i=1; i<=size(factors); i++) {
        printf("factors[%s]: %s",i,factors[i]);
        fact = factorize(factors[i]);
        print("fact:");
        print(fact);

        for(j=2; j<=size(fact[1]); j++) {
          lcoeff = leadcoef(fact[1][j]);
          fact[1][j] = fact[1][j]/lcoeff;
          fact[1][1] = fact[1][1]*(lcoeff^fact[2][j]); // polynomial is monic (thus unique)
          lcoeff = content(fact[1][j]);
          fact[1][j] = fact[1][j]/lcoeff;
          fact[1][1] = fact[1][1]*(lcoeff^fact[2][j]); // polynomial has nice coefficients

          for(k=1; 1; k++) {
            if(q[k]==fact[1][j]) {
              e[k] = e[k] + fact[2][j]*exponents[i];
              break;
            }
            if(k>=size(q)) {
              q[size(q)+1] = fact[1][j];
              e[size(e)+1] = fact[2][j]*exponents[i];
              break;
            }
          }
        }
        constant = constant * number(fact[1][1])^exponents[i];
      }
      f = f/constant;

      int m = size(q);
      printf("f: %s%nq: %s%ne: %s",f,q,e);
      if(debug) {t1 = rtimer-t1; fprintf(l,"done! (%s ms)", t1);}
      list input = list(q, list(list(poly(f),1..m,e)));
    } else {
      ERROR("wrong type for second argument, expected list(ideal, intvec) or list(poly, ideal)");
    }}
  } else {
    ERROR("wrong type for second argument, expected poly or list");
  }}

  list input = list(q, list(list(poly(f),1..m,e)));
  if (debug) {
    return (input, t1);
  } else {
    return (input);
  }
}

proc pfd_functional_unit(list terms, ideal q, intvec steps, list #)
{
  int counter, tt, ttt, t2, t3, t4, t5;
  list dec;

  if ((size(#) > 3) || (size(#) == 2)) {
    ERROR("Expected 3, 4 or 6 arguments in pfd_functional_unit, got " +
          string(size(#) + 3) + " instead");
  }
  int debug = 0;
  link l = ":w";
  link li = ":w";
  int save_int_res = 0;
  if (size(#) > 0) {
    save_int_res = #[1];
  }
  if (size(#) == 3) {
    debug = #[2];
    l = #[3];
  }

  /*** Nullstellensatz decomposition *********************************/
  if (steps[1]) {
    if (debug) {t2 = rtimer; write(l, "Nullstellensatz decomposition");}
    terms = generic_dec_loop("NSSdecompStep", "size", terms, q, debug, l);
    if (debug) {t2 = rtimer - t2; fprintf(l, "(%s ms, %s terms)", t2, size(terms));}
    if(save_int_res)
    {
      write("ssi:w " + string(save_int_res) + "_result_after_step_1.ssi",
            list(q, terms));
    }
  } else {
    if(debug) {write(l,"skipping nullstellensatz decomposition");}
  }

  /*** Short numerator decomposition *********************************/
  if (steps[2]) {
    if (debug) {t3 = rtimer; write(l, "short numerator decomposition");}
    terms = generic_dec_loop("shortNumeratorDecompStep", "index", terms, q, debug, l);
    if (debug) {t3 = rtimer - t3; fprintf(l, "(%s ms, %s terms)", t3, size(terms));}
    if(save_int_res)
    {
      li = "ssi:w " + string(save_int_res) + "_result_after_step_2.ssi";
      write(li, list(q, terms));
    }
  } else {
    if(debug) {write(l,"skipping short numerator decomposition");}
  }

  /*** Algebraic dependence decomposition ****************************/
  if (steps[3]) {
    if (debug) {t4 = rtimer; write(l, "algebraic dependence decomposition");}
    terms = generic_dec_loop("algDependDecompStep", "size", terms, q, debug, l);
    if (debug) {t4 = rtimer - t4; fprintf(l, "(%s ms, %s terms)", t4, size(terms));}
    if(save_int_res)
    {
      li = "ssi:w " + string(save_int_res) + "_result_after_step_3.ssi";
      write(li, list(q, terms));
    }
  } else {
    if(debug) {write(l,"skipping algebraic dependence decomposition");}
  }

  /*** Numerator decomposition ***************************************/
  if (steps[4]) {
    if (debug) {t5 = rtimer; write(l, "numerator decomposition");}
    terms = generic_dec_loop("numeratorDecompStep", "index", terms, q, debug, l);
    if (debug) {t5 = rtimer - t5; fprintf(l, "(%s ms, %s terms)", t5, size(terms));}
    if(save_int_res)
    {
      li = "ssi:w " + string(save_int_res) + "_result_after_step_4.ssi";
      write(li, list(q, terms));
    }
  } else {
    if(debug) {write(l,"skipping numerator decomposition");}
  }

  dec = terms;

  if (size(dec) == 1) {if(dec[1][1]==0){dec = list();}}
  dec = list(q, dec);

  if (voice <= printlevel) {displaypfd(dec)}

  if (debug) {
    return (dec, t2, t3, t4, t5);
  } else {
    return (dec);
  }
}

proc generic_dec_loop( string decomp
                     , string mergetype
                     , list terms
                     , ideal q
                     , list #)
{
  list dec,newterms,result;
  int imax;
  int i;
  int tt,ttt;
  string command;
  list merged;
  int debug = 0;
  link l = ":w";
  int counter = 0;

  if (size(#)> 0) {
    debug = #[1];
    l = #[2];
  }

  while (size(terms) > 0) {
    if (debug) {tt = rtimer; counter++;}
    newterms = list();

    for (i = 1; i<= size(terms); i++) {
      command = "result = " + decomp + "(terms[i],q,#);";
      execute(command);

      if(debug) {ttt = rtimer;}
      merged = general_merge_step(mergetype, newterms, dec, result);
      dec = merged[1];
      newterms = merged[2];
      if(debug)
        {fprintf(l,"      merging: %s ms, %s new terms", rtimer-ttt, size(result));}
    }
    terms = newterms;
    if (debug)
      {fprintf(l,"  %s: %s ms, %s terms, %s unfinished",
       counter, rtimer-tt, size(terms)+size(dec),size(terms));}
  }

  return (dec);
}

proc general_merge_step(string mergetype, list newterms, list dec, list result)
{
  if (mergetype == "size") {
    if(size(result)>1) {newterms = mergepfd(newterms, result);}
    else                    {dec = mergepfd(dec,      result);}

    return (dec, newterms);
  }
  if (mergetype == "index") {
    newterms = mergepfd(newterms, result[1]);
    dec = mergepfd(dec, result[2]);

    return (dec, newterms);
  }
  return (list());
}

static proc NSSdecompStep(list l, ideal q, list #)
{
  poly f=l[1];
  intvec indices=l[2];
  intvec e=l[3];
  int m = size(indices);

  if(m==0) // denominator is 1
    {return(list(l));} // do nothing, return input

  ideal qe = q[indices];
  for(int i=1; i<=m; i++)
    {qe[i] = qe[i]^e[i];}
  matrix T;
  ideal qe_std = liftstd(qe,T);

  if(deg(qe_std) == 0)
  {
    T = T/qe_std[1];
      // now 1 = T[1,1]*qe[1] + ... + T[m,1]*qe[m] is a Nullstellensatz certificate
    list dec;
    poly h;
    for(i=1; i<=m; i++)
    {
      h = T[i,1];
      if(h != 0)
        {dec[size(dec)+1] = list(f*h,delete(indices,i),delete(e,i));}
    }
    return(dec);
  }
  else
  {
    return(list(l)); // do nothing, return input
  }
}

static proc shortNumeratorDecompStep(list l, ideal q, list #)
{
  int debug=0;
  if(size(#)>0) {debug=#[1]; link ll=#[2];}
  if(debug) {system("--ticks-per-sec",1000); int tt=rtimer;}

  poly f=l[1];
  intvec indices=l[2];
  intvec e=l[3];
  int m = size(indices);

  if(m==0) // denominator is 1
  {
    if(debug)
      {fprintf(ll,"      shortNumeratorDecompStep: %s ms (m=%s, e=%s) "
                    +"--> constant denominator", rtimer-tt, m, e);}
    return(list(list(),list(l))); // do nothing, return input
  }

  ideal q_denom = q[indices]; // factors occuring in the denominator
  matrix T;
  ideal q_std = liftstd(q_denom,T);
  list divrem = division(f,q_std);
  poly r = divrem[2][1]/divrem[3][1,1];

  if(r!=0)
  {
    if(debug)
      {fprintf(ll,"      shortNumeratorDecompStep: %s ms (m=%s, e=%s) "
                  +"--> remainder is nonzero", rtimer-tt, m, e);}
    return(list(list(),list(l))); // if there is a rest, decomposing further would
  }                               // not help in the next step (alg. depend. decomposition)

  matrix a = divrem[1]/divrem[3][1,1]; // now f = r + a[1,1]*q_std[1] + ... +a[m,1]*q_std[m]
  a = T*a;   // lift coefficients   ==>   now f = r + a[1,1]*q[1]     + ... +a[m,1]*q[m]

  // reduce w.r.t. groebner basis of syz(q) to make the numerators "smaller":
  vector v;
  for(int i=1; i<=m; i++) {v = v + gen(i)*a[i,1];}
  v = reduce(v, std(syz(q_denom)));

  list fraction,dec;
  for(i=1; i<=m; i++)
  {
    if(v[i] == 0)
    {
      i++;
      continue;
    }
    fraction[1] = v[i];
    if(e[i]==1)
      {
        fraction[2] = delete(indices,i);
        fraction[3] = delete(e,i);
      }
    else
    {
      fraction[2] = indices;
      fraction[3] = e;
      fraction[3][i] = fraction[3][i] - 1;
    }
    dec[size(dec)+1] = fraction;
  }

  if(debug)
    {fprintf(ll,"      shortNumeratorDecompStep: %s ms (m=%s, e=%s, deg(v)=%s, size(v)=%s)",
     rtimer-tt, m, e, deg(v), size(v));}
  return(list(dec,list()));
}

static proc algDependDecompStep(list l, ideal q, list #)
{
  int debug=0;
  if(size(#)>0) {debug=#[1]; link ll=#[2];}
  if(debug) {system("--ticks-per-sec",1000); int tt=rtimer;}
  def br = basering;
  int d = nvars(br);
  intvec indices=l[2];
  int m = size(indices);
  intvec e=l[3];
  int i;

  if(m==0) // denominator is 1
  {
    if(debug)
      {fprintf(ll,"      algDependDecompStep: %s ms (m=%s, e=%s)", rtimer-tt, m, e);}
    return(list(l)); // do nothing, return input
  }

  if(m<=d)
  {
    if(size(syz(module(transpose(jacob(ideal(q[indices]))))))==0) // jacobian criterion
    {
      if(debug)
        {fprintf(ll,"      algDependDecompStep: %s ms (m=%s, e=%s) "
                    +"--> alg. indep.", rtimer-tt, m, e);}
      return(list(l)); // do nothing, return input
    }
  }
  //printf("%nq=%s",q);
  //printf("indices=%s",indices);

  def R = changeord(list(list("dp",m+d)),extendring(m, "y(", "dp", 1, changevar("x()",br)));
  setring(R);

  list l = fetch(br,l);
  ideal q = fetch(br,q);
  poly f=l[1];

  ideal I;
  for(i=1; i<=m; i++)
    {I[i] = y(i)-q[indices[i]];}

  ideal annihilatingPolys = eliminate(I,intvec(1..d));

  poly g = annihilatingPolys[1];

  poly tail = g[size(g)];    // term of lowest dp-order (thus lowest degree)
  //printf("tail: %s",tail);
  number tcoeff = leadcoef(tail);
  intvec texpon = leadexp(tail);
  texpon = texpon[(d+1)..(d+m)];
  g = g-tail;
  poly term;
  number coeff;
  intvec expon;
  list fraction,dec;
  int pow;
  int jmax = size(g);
  for(int j=1; j<=jmax; j++)
  {
    term = g[j];
    coeff = leadcoef(term);
    expon = leadexp(term);
    expon = expon[(d+1)..(d+m)];
    fraction[1] = -f*coeff/tcoeff;
    fraction[2] = intvec(0:0);
    fraction[3] = intvec(0:0);
    for(i=1; i<=m; i++)
    {
      pow = expon[i]-texpon[i]-e[i];
      if(pow>=0)
      {
        fraction[1] = fraction[1]*q[indices[i]]^pow;
      }
      else
      {
        fraction[2][size(fraction[2])+1] = indices[i];
        fraction[3][size(fraction[3])+1] = -pow;
      }
    }
    dec[size(dec)+1] = fraction;
  }
  setring(br);
  list dec = fetch(R,dec);
  if(debug)
    {fprintf(ll,"      algDependDecompStep: %s ms (m=%s, e=%s)", rtimer-tt, m, e);}
  return(dec);
}

static proc numeratorDecompStep(list l, ideal q, list #)
{
  int debug=0;
  if(size(#)>0) {debug=#[1]; link ll=#[2];}
  if(debug) {system("--ticks-per-sec",1000); int tt=rtimer;}

  poly f=l[1];
  intvec indices=l[2];
  intvec e=l[3];
  int m = size(indices);

  if(m==0) // denominator is 1
  {
    if(debug)
      {fprintf(ll,"      numeratorDecompStep: %s ms (m=%s, e=%s) "
                  +"--> constant denominator", rtimer-tt, m, e);}
    return(list(list(),list(l))); // do nothing, return input
  }

  ideal q_denom = q[indices]; // factors in the denominator
  matrix T;
  ideal q_std = liftstd(q_denom,T);
  list divrem = division(f,q_std);
  matrix a = divrem[1]/divrem[3][1,1];
  poly r = divrem[2][1]/divrem[3][1,1]; // now f = r + a[1,1]*q_std[1] + ... +a[m,1]*q_std[m]
  a = T*a;   // lift coefficients    ==>   now f = r + a[1,1]*q[1]     + ... +a[m,1]*q[m]

  // reduce w.r.t. groebner basis of syz(q) to make the numerators "smaller"
  vector v;
  for(int i=1; i<=m; i++) {v = v + gen(i)*a[i,1];}
  v = reduce(v, std(syz(q_denom)));
  //printf("%nv=%s",v);
  //printf("num=%s",f);
  //printf("den=q[%s] ^ %s",indices,e);
  //printf("remainder=%s",r);
  list fraction,dec,rest;
  if(r!=0)
    {rest[1] = list(r,indices,e);}
  for(i=1; i<=m; i++)
  {
    if(v[i] == 0)
    {
      i++;
      continue;
    }
    fraction[1] = v[i];
    if(e[i]==1)
      {
        fraction[2] = delete(indices,i);
        fraction[3] = delete(e,i);
      }
    else
    {
      fraction[2] = indices;
      fraction[3] = e;
      fraction[3][i] = fraction[3][i] - 1;
    }
    dec[size(dec)+1] = fraction;
  }

  if(debug)
    {fprintf(ll,"      numeratorDecompStep: %s ms (m=%s, e=%s, deg(v)=%s, size(v)=%s)",
     rtimer-tt, m, e, deg(v), size(v));}
  return(list(dec,rest));
}

static proc mergepfd(list dec1, list dec2)
{
  // Note: assumes dec1 is already sorted w.r.t. dp in the denominator exponents
  int n1=size(dec1);
  int n2=size(dec2);
  if(n2==0) {return(dec1);}
  int i;
  int a,b,m;
  list entry;
  for(i=1; i<=n2; i++)
  {
    entry = dec2[i];
    if(n1==0)
    {
      dec1=list(entry);
      n1++;
      i++; // Required with for loop continue in Singular because REaSoNs?
      continue;
    }

    a=1;
    b=n1;
    m = (a+b) div 2;
    while(b>a)
    {
      if(is_dp_smaller(dec1[m][2], dec1[m][3], entry[2], entry[3]))
      {
        a=m+1;
      }
      else
      {
        b=m;
      }
      m = (a+b) div 2;
    }
    if(is_dp_smaller(dec1[a][2], dec1[a][3], entry[2], entry[3]))
      {dec1=insert(dec1,entry,a); n1++;}
    else{if(entry[2]==dec1[a][2] && entry[3]==dec1[a][3])
    {
      dec1[a][1] = dec1[a][1] + entry[1];   //same denominator: add numerators
      if(dec1[a][1]==0)
        {dec1 = delete(dec1,a); n1--;}
    }
    else
      {dec1=insert(dec1,entry,a-1); n1++;}}
  }
  return(dec1);
}

proc mergepfd_sorted(list dec1, list dec2)
{
  // Note: assumes both are already sorted w.r.t. dp in the denominator exponents
  int n1=size(dec1);
  int n2=size(dec2);
  if(n2==0) {return(dec1);}
  if(n1==0) {return(dec2);}

  list merged = list();

  int i1 = 1;
  int i2 = 1;
  while (i1 <= n1 || i2 <= n2) {
    if (i1 > n1) {
      merged = merged + list(dec2[i2]);
      i2++;
      continue;
    }
    if (i2 > n2) {
      merged = merged + list(dec1[i1]);
      i1++;
      continue;
    }
    // Both indices are valid for the lists
    if(is_dp_smaller(dec1[i1][2], dec1[i1][3], dec2[i2][2], dec2[i2][3])) {
      // dec1 is smaller
      merged = merged + list(dec1[i1]);
      i1++;
    } else{if (dec2[i2][2]==dec1[i1][2] && dec2[i2][3]==dec1[i1][3]) {
      def coeff = dec1[i1][1] + dec2[i2][1];
      if (coeff != 0) {
        merged = merged + list(list(coeff, dec1[i1][2], dec1[i1][3]));
      }
      i1++;
      i2++;
    } else {
      // dec2 is smaller
      merged = merged + list(dec2[i2]);
      i2++;
    }}
  }

  return(merged);
}


static proc is_dp_smaller(intvec indices1, intvec e1, intvec indices2, intvec e2)
{
  if(size(e2)==0) {return(0);}
  if(size(e1)==0) {return(1);}
  int s1,s2 = sum(e1),sum(e2);
  if(s1<s2) {return(1);}
  if(s1>s2) {return(0);}
  int n1,n2 = size(indices1),size(indices2);
  int imax = min(n1,n2);
  for(int i=0; i<imax; i++)
  {
    if(indices1[n1-i]>indices2[n2-i]) {return(1);}
    if(indices1[n1-i]<indices2[n2-i]) {return(0);}
    if(e1[n1-i]>e2[n2-i]) {return(1);}
    if(e1[n1-i]<e2[n2-i]) {return(0);}
  }
  return(0);
}

proc checkpfd(list fraction, def dec, list #)
"USAGE:   checkpfd(list(f,g),dec[,N,C]);   f,g poly, dec list, N,C int
RETURN:   0 or 1
PURPOSE:  test for (mathematical) equality of f/g and a partial fraction
          decomposition dec. The list dec has to have the same structure as the
          output of @ref{leinartas_adapted}.
       @* The denominator g can also be given in factorized form as a list of
          an ideal of irreducible non constant polynomials and an intvec of
          exponents. This can save time since the first step in the algorithm is
          to factorize g. (a list of the zero-ideal and an empty intvec
          represents a denominator of 1.)
       @* By default the test is done (exactly) by bringing all terms of the
          decomposition on the same denominator and comparing to f/g.
       @* If additional parameters N [, C] are given and if @code{N>0}, a
          probabilistic method is chosen: evaluation at N random points with
          coordinates between -C and C. This may be faster for big polynomials.
SEE ALSO: leinartas_adapted
EXAMPLE:  example checkpfd; shows an example"
{
  poly f = fraction[1];
  if(typeof(fraction[2])=="poly" || typeof(fraction[2])=="number" || typeof(fraction[2])=="int" || typeof(fraction[2])=="bigint")
    {if(fraction[2]==0) {ERROR("division by 0");}}
  def g = fraction[2];
  if(size(#)>0)
  {
    if(#[1]>0)
    {
      int N = #[1]; // number of random tests
      int max_val=16;
      if(size(#)>1) {max_val = #[2];}
      ideal values;
      ideal vars = maxideal(1);
      int d=nvars(basering);
      number val1,val2;
      int div_by_0;
      int i,j;
      for(i=1; i<=N; i++)
      {
        values = ideal(random(max_val,1,d));

        if(typeof(g)=="poly" || typeof(g)=="number" || typeof(g)=="int" || typeof(g)=="bigint")
          {val1 = number(substitute(poly(g),vars,values));}
        else{if(typeof(g)=="list") // denominator given in factorized form
        {
          val1 = number(1);
          for(j=1; j<=size(g[1]); j++)
            {val1 = val1 * number(substitute(g[1][j]^g[2][j],vars,values));}
        }
        else {ERROR("wrong type for second argument, expected poly or list");}}

        if(val1==0) {continue;}
        val1 = number(substitute(f,vars,values))/val1;
        val2, div_by_0 = evaluatepfd(dec,values,2);
        if(div_by_0) {continue;}
        if(val1 != val2)
          {return(0);}
      }
      return(1);
    }
  }
  if(typeof(dec)=="list")
  {
    ideal q = dec[1];
    list terms = dec[2];
    if (size(dec) >= 3) {
      list nonlin = dec[3];
    }
  }
  else{if(typeof(dec)=="partfrac")
  {
    ideal q = dec.q;
    list terms = dec.terms;
  }
  else{if(typeof(dec)=="partfrac2")
  {
    ideal q = denominator_factors;
    list terms = dec.terms;
  }
  else
    {ERROR("wrong argument type, expected list or partfrac, got "+typeof(dec));}
  }}

  if(size(terms)==0) {return(f==0);}
  int m = size(q);
  if(m==0)
  {
    if(size(terms)!=1) {ERROR("invalid input");}
    if(size(terms[1][2])!=0) {ERROR("invalid input");}
    poly term = terms[1][1];

    poly denom=1;
    if(typeof(g)=="poly" || typeof(g)=="number" || typeof(g)=="int" || typeof(g)=="bigint")
      {denom=g;}
    else{if(typeof(g)=="list")    //denominator given in factorized form
      {for(i=1;i<=size(g[1]);i++) {denom = denom * g[1][i]^g[2][i];}}
    else {ERROR("wrong type for second argument, expected poly or list");}}

    if(deg(denom)>0)
    {
      if(reduce(f,denom)==0)
      {
        return(f div denom == term);
      }
      return(0);
    }
    return(f/denom == term);
  }

  int jmax,j,ind,k;
  intvec e_max=0:m;
  int imax = size(terms);
  for(int i=1; i<=imax; i++)
  {
    jmax = size(terms[i][2]);
    for(j=1; j<=jmax; j++)
    {
      ind = terms[i][2][j];
      e_max[ind] = max(e_max[ind],terms[i][3][j]);
    }
  }
  poly num;
  poly sum_of_numerators = 0;
  intvec e;
  for(i=1; i<=imax; i++)
  {
    e = e_max;
    jmax = size(terms[i][2]);
    for(j=1; j<=jmax; j++)
    {
      ind = terms[i][2][j];
      e[ind] = e[ind]-terms[i][3][j];
    }
    num = terms[i][1];
    for(j=1; j<=m; j++)
      {num = num * q[j]^(e[j]);}
    sum_of_numerators = sum_of_numerators + num;
  }
  // the decomposition is now equal to sum_of_numerators/product(q[i]^e_max[i]) (i from 1 to imax)

  //if nonlin is defined, then the denominator needs them as well
  if (defined(nonlin)) {
    for (i = 1; i <= size(nonlin[1]); i++) {
      q = q + nonlin[1][i];
      e_max[m + i] = nonlin[2][i];
    }
    m = size(q);
    if (m != size(e_max)) {
      ERROR("Badly formatted data?");
    }
  }

  // now: check if this equals f/g:
  if(typeof(g)=="poly" || typeof(g)=="number" || typeof(g)=="int" || typeof(g)=="bigint")
  {
    list fact = factorize(poly(g));
    ideal q_g = delete(fact[1],1);
    intvec e_g = delete(fact[2],1);
    num = f/fact[1][1];
  }
  else{if(typeof(g)=="list")    //denominator given in factorized form
  {
    ideal q_g = g[1];
    intvec e_g = g[2];
    num = f;
  }
  else {ERROR("wrong type for second argument, expected poly or list");}}

  int m_g = size(q_g);
  int expon;
  number c;
  for(i=1; i<=m_g; i++)
  {
    j=0;
    for(k=1; k<=m; k++)
    {
      c = leadcoef(q[k])/leadcoef(q_g[i]);
      if(c*q_g[i]==q[k]) {j=k; break;}
    }
    if(j==0)
      {sum_of_numerators = sum_of_numerators*q_g[i]^e_g[i];}
    else
    {
      num = num*(c^e_g[i]);    //fix lead coefficient
      expon = e_g[i]-e_max[j];
      if(expon>0)
        {sum_of_numerators = sum_of_numerators*q[j]^expon;}
      else{if(expon<0)
        {num = num*q[j]^(-expon);}}
    }
  }
  return(sum_of_numerators==num);
}
example
{
  "EXAMPLE:";
  echo=voice;
  ring R = 0,(x,y),dp;
  poly f = x^3+3*x^2*y+2*y^2-x^2+4*x*y;
  poly g = x^2*y*(x-1)*(x-y)^2;

  // partial fraction decomposition of f/g:
  list dec = leinartas_adapted(f,g);
  // some other decomposition (not equal to f/g):
  list wrong_dec = leinartas_adapted(f+1,g);

  displaypfd_long(dec);
  list fraction = f,g;

  // exact test:
  checkpfd(fraction,dec);
  checkpfd(fraction,wrong_dec);
  // probabilistic test (evaluation at 10 random points):
  checkpfd(fraction,dec,10);
  checkpfd(fraction,wrong_dec,10);
}

proc evaluatepfd(def dec, ideal values, list #)
"USAGE:   evaluatepfd(dec, values[, mode]);   dec list, values ideal, mode int
RETURN:   the number gotten by substituting the numbers generating the ideal
          @code{values} for the variables in the partial fraction decomposition
          @code{dec}. The list @code{dec} has to have the same structure as the
          output of @ref{leinartas_adapted}.
       @* @code{mode=1}: raise Error in case of division by 0 (default)
       @* @code{mode=2}: return a second integer which is 1 if the denominator
          becomes 0, and 0 otherwise.
SEE ALSO: leinartas_adapted
EXAMPLE:  example evaluatepfd; shows an example"
{
  if(typeof(dec)=="list")
  {
    ideal q = dec[1];
    list terms = dec[2];

    if (size(dec) >= 3) {
      list nonlin = dec[3];
    }
  }
  else{if(typeof(dec)=="partfrac")
  {
    ideal q = dec.q;
    list terms = dec.terms;
  }
  else{if(typeof(dec)=="partfrac2")
  {
    ideal q = denominator_factors;
    list terms = dec.terms;
  }
  else
    {ERROR("wrong argument type, expected list or partfrac, got "+typeof(dec));}
  }}
  if(size(terms)==0) {return(number(0));}

  int mode = 1;
  if(size(#)>0) {mode = #[1];}

  ideal vars = maxideal(1); // ideal generated by ring variables
  number val=0;
  number denom;
  int i,j,m;
  for(i=1; i<=size(terms); i++)
  {
    //v, j = evaluatepfd_single_term(terms[i], q, vars, values, mode)
    denom = 1;
    m = size(terms[i][2]);
    for(j=1; j<=m; j++)
    {
      denom = denom * (number(substitute(q[terms[i][2][j]],vars,values)))^terms[i][3][j];
      if(denom == 0)
      {
        if(mode==1) {ERROR("division by 0");}
        else {return(0,1);};
      }
    }
    val = val + number(substitute(terms[i][1],vars,values))/denom;
  }

  // nonlins, if applicable
  if (defined(nonlin)) {
    number nonlinval = 1;
    for (i = 1; i <= size(nonlin[1]); i++) {
      nonlinval = nonlinval * number(substitute(nonlin[1][i], vars, values))^nonlin[2][i];
    }
    if (nonlinval == 0) {
      if (mode == 1) {
        ERROR("division by 0");
      } else {
        return (0, 1);
      }
    }
    val = val / nonlinval;
  }


  if(mode==1) {return(val);}
  else {return(val,0);}
}
example
{
  "EXAMPLE:";
  echo=voice;
  ring R = 0,(x,y),dp;
  poly f = x+2*y;
  poly g = x^2-y^2;

  // partial fraction decomposition of f/g:
  list dec = leinartas_adapted(f,g);

  displaypfd_long(dec);
  // evaluation at x=2, y=1:
  ideal values = 2,1;
  evaluatepfd(dec,values);

  // compare: f(2,1)/g(2,1) = (2+2*1)/(2^2-1^1) = 4/3
}

static proc evaluatepfd_single_term(list term, ideal q, ideal vars, ideal values)
{
  number denom = 1;
  int m = size(term[2]);
  for(int j=1; j<=m; j++)
  {
    denom = denom * (number(substitute(q[term[2][j]],vars,values)))^term[3][j];
    if(denom == 0) {return(0,1);}
  }
  return(number(substitute(term[1],vars,values))/denom);
}

static proc elementwise_equality(def a, def b)
{
  if(typeof(a)=="list" && typeof(b)=="list")
  {
    int n=size(a);
    if(n!=size(b)) {return(0);}
    for(int i=1;i<=n;i++)
    {
      if(not(elementwise_equality(a[i],b[i]))) {return(0);}
    }
    return(1);
  }
  if(typeof(a)=="ideal" && typeof(b)=="ideal")
  {
    int n=size(a);
    if(n!=size(b)) {return(0);}
    for(int i=1;i<=n;i++)
    {
      if(not(elementwise_equality(a[i],b[i]))) {return(0);}
    }
    return(1);
  }
  if(typeof(a)=="list" && typeof(b)!="list") {return(0);}
  if(typeof(a)!="list" && typeof(b)=="list") {return(0);}
  if(typeof(a)=="ideal" && typeof(b)!="ideal") {return(0);}
  if(typeof(a)!="ideal" && typeof(b)=="ideal") {return(0);}
  return(a==b);
}

proc find_entry(def l, def entry)
{
  int n=size(l);
  for(int i=1; i<=n; i++)
    {if(elementwise_equality(entry,l[i])) {return(i);}}
  return(0);
}

proc displaypfd(def dec)
"USAGE:   displaypfd(dec);   dec list
PURPOSE:  print a partial fraction decomposition @code{dec} in a readable way.
          The list @code{dec} has to have the same structure as the output of
          @ref{leinartas_adapted}.
SEE ALSO: leinartas_adapted, displaypfd_long, getStringpfd, getStringpfd_indexed
EXAMPLE:  example displaypfd; shows an example"
{
  if(typeof(dec)=="list")
  {
    ideal q = dec[1];
    list terms = dec[2];
  }
  else{if(typeof(dec)=="partfrac")
  {
    ideal q = dec.q;
    list terms = dec.terms;
  }
  else{if(typeof(dec)=="partfrac2")
  {
    ideal q = denominator_factors;
    list terms = dec.terms;
  }
  else
    {ERROR("wrong argument type, expected list or partfrac, got "+typeof(dec));}
  }}
  int nterms=size(terms);
  if(nterms==0) {print("0"); return();}
  if(nterms==1 && size(terms[1][2])==0) {print(terms[1][1]); return();}
  int jmax,j;
  string s1,s2;
  for(int i=1; i<=nterms; i++)
  {
    s1 = "(" + string(terms[i][1]);
    if(i>1) {s1 = "+ " + s1;}
    else {s1 = "  " + s1;}
    if(size(terms[i][2])>0)
    {
      s2 = ") / (";
      jmax = size(terms[i][2]);
      for(j=1; j<=jmax; j++)
      {
        s2 = s2 + "q" + string(terms[i][2][j]);
        if(terms[i][3][j] != 1) {s2 = s2 + "^" + string(terms[i][3][j]);}
        if(j<jmax) {s2 = s2 + "*";}
      }
      s2 = s2 + ")";
    }
    else {s2 = ")";}

    if(size(s1)+size(s2)>192) {s1=s1[1..(192-size(s2))]; s1 = s1 + "... ";}
    print(s1+s2);
  }
  if(size(q)>0) {print("where");}
  for(i=1; i<=size(q); i++)
  {
    printf("q%s = %s",i,q[i]);
  }
  if(size(terms)==1) {printf("(%s term)", 1);}
  else {printf("(%s terms)", size(terms));}
}
example
{
  "EXAMPLE:";
  echo=voice;
  ring R = 0,(x,y),dp;
  poly f = x^3+3*x^2*y+2*y^2-x^2+4*x*y;
  poly g = x^2*y*(x-1)*(x-y)^2;

  list dec = leinartas_adapted(f,g);

  displaypfd(dec);
}

proc displaypfd_long(def dec)
"USAGE:   displaypfd_long(dec);   dec list
PURPOSE:  like @ref{displaypfd}, but denominators are written out, not indexed.
SEE ALSO: pfd, displaypfd, getStringpfd, getStringpfd_indexed
EXAMPLE:  example displaypfd_long; shows an example"
{
  if(typeof(dec)=="list")
  {
    ideal q = dec[1];
    list terms = dec[2];
  }
  else{if(typeof(dec)=="partfrac")
  {
    ideal q = dec.q;
    list terms = dec.terms;
  }
  else{if(typeof(dec)=="partfrac2")
  {
    ideal q = denominator_factors;
    list terms = dec.terms;
  }
  else
    {ERROR("wrong argument type, expected list or partfrac, got "+typeof(dec));}
  }}
  int nterms = size(terms);
  if(nterms==0) {print("0"); return();}
  if(nterms==1 && size(terms[1][2])==0) {print(terms[1][1]); return();}
  print("  "+getStringFraction(terms[1],q));
  for(int i=2; i<=nterms; i++)
    {print("+ "+getStringFraction(terms[i],q));}
  if(size(terms)==1) {printf("(%s term)", 1);}
  else {printf("(%s terms)", size(terms));}
}
example
{
  "EXAMPLE:";
  echo=voice;
  ring R = 0,(x,y),dp;
  poly f = x^3+3*x^2*y+2*y^2-x^2+4*x*y;
  poly g = x^2*y*(x-1)*(x-y)^2;

  list dec = leinartas_adapted(f,g);

  displaypfd_long(dec);
}

proc getStringpfd(def dec)
"USAGE:   getStringpfd(dec);   dec list
PURPOSE:  turn a partial fraction decomposition @code{dec} into one string. The
          list @code{dec} has to have the same structure as the output of
          @ref{leinartas_adapted}.
SEE ALSO: leinartas_adapted, getStringpfd_indexed, displaypfd, displaypfd_long
EXAMPLE:  example getStringpfd; shows an example"
{
  if(typeof(dec)=="list")
  {
    ideal q = dec[1];
    list terms = dec[2];
  }
  else{if(typeof(dec)=="partfrac")
  {
    ideal q = dec.q;
    list terms = dec.terms;
  }
  else{if(typeof(dec)=="partfrac2")
  {
    ideal q = denominator_factors;
    list terms = dec.terms;
  }
  else
    {ERROR("wrong argument type, expected list or partfrac, got "+typeof(dec));}
  }}
  int nterms = size(terms);
  if(nterms==0) {return("0");}
  string s = getStringFraction(terms[1],q);
  for(int i=2; i<=nterms; i++)
    {s = s+" + "+getStringFraction(terms[i],q);}
  return(s);
}
example
{
  "EXAMPLE:";
  echo=voice;
  ring R = 0,(x,y),dp;
  poly f = x^3+3*x^2*y+2*y^2-x^2+4*x*y;
  poly g = x^2*y*(x-1)*(x-y)^2;

  list dec = leinartas_adapted(f,g);

  displaypfd_long(dec);
  getStringpfd(dec);
}

proc getStringpfd_indexed(def dec)
"USAGE:   getStringpfd_indexed(dec);   dec list
PURPOSE:  turn a partial fraction decomposition @code{dec} into one string,
          writing the denominator factors just as @code{q1},@code{q2},... . The
          list @code{dec} has to have the same structure as the output of
          @ref{leinartas_adapted}.
SEE ALSO: leinartas_adapted, getStringpfd, displaypfd, displaypfd_long
EXAMPLE:  example getStringpfd_indexed; shows an example"
{
  int i;
  if(typeof(dec)=="list")
  {
    if(typeof(dec[1])=="ideal") {list terms = dec[2];}
    else {list terms = dec;}
  }
  else{if(typeof(dec)=="partfrac")
  {
    list terms = dec.terms;
  }
  else{if(typeof(dec)=="partfrac2")
  {
    ideal q = denominator_factors;
    list terms = dec.terms;
  }
  else
    {ERROR("wrong argument type, expected list or partfrac, got "+typeof(dec));}
  }}
  if (size(terms) == 0) {
    return("0");
  }


  string s = getStringFraction_indexed(terms[1]);

  for (i = 2; i <= size(terms); i++) {
    s = s + " + " + getStringFraction_indexed(terms[i]);
  }
  return(s);
}
example
{
  "EXAMPLE:";
  echo=voice;
  ring R = 0,(x,y),dp;
  poly f = x^3+3*x^2*y+2*y^2-x^2+4*x*y;
  poly g = x^2*y*(x-1)*(x-y)^2;

  list dec = leinartas_adapted(f,g);

  displaypfd(dec);
  getStringpfd_indexed(dec);
}

static proc getStringFraction(list fraction, ideal q)
{
  int jmax,j;
  string s = "(" + string(fraction[1]);
  if(size(fraction[2])>0)
  {
    s = s + ")/(";
    jmax = size(fraction[2]);
    for(j=1; j<=jmax; j++)
    {
      s = s + "(" + string(q[fraction[2][j]]) + ")";
      if(fraction[3][j] != 1) {s = s + "^" + string(fraction[3][j]);}
      if(j<jmax) {s = s + "*";}
    }
  }
  s = s + ")";
  return(s);
}

static proc indexed_factors_as_txt(list factors)
{
  int i;
  string factors_txt = "";
  if (size(factors) == 0) {
    return ("1");
  }
  if (size(factors[1]) != size(factors[2])) {
    factors;
    ERROR("indices and entries should be the same size ");
  }
  for (i = 1; i <= size(factors[1]); i++) {
    if (i > 1) {
      factors_txt = factors_txt + "*";
    }
    factors_txt = factors_txt + "q" + string(factors[1][i]);
    if (factors[2][i] != 1) {
      factors_txt = factors_txt + "^" + string(factors[2][i]);
    }
  }
  if (factors_txt == "") {
    return ("1");
  }
  return (factors_txt);
}

static proc polynomial_as_txt (string name, list #)
{
  if (size(#) != 1) {
    ERROR("Please provide exactly one list or polynomial as argument: " +
    string(#) + " as " + name);
  }

  if (typeof(#[1]) == "list") {
    return (indexed_factors_as_txt(#[1]));
  } else{if (typeof(#[1]) == "poly") {
    return (string(#[1]));
  } else {
    ERROR("Please provide a list or polynomial as argument, got " + typeof(#[1])
    + " " +  string(#[1]));
  }}
}

static proc getStringFraction_indexed(list fraction)
{
  int jmax,j;
  string s;
  if (typeof(fraction[1]) == "poly") {
    string num_txt = polynomial_as_txt("numerator", list(fraction[1]));
  } else {
    if (typeof(fraction[1]) != "list") {
      ERROR("Expected poly or list");
    }
    string l_coeff = string(fraction[1][1]);

    string num_txt = polynomial_as_txt( "numerator"
                                      , list( list( fraction[1][2]
                                                  , fraction[1][3]
                                                  )
                                            )
                                      );
    if (l_coeff == "1") {
      l_coeff = "";
    }
    if (num_txt == "1") {
      num_txt = "";
    }


    if ( size(l_coeff) == 0 || size(num_txt) ==  0) {
      num_txt = l_coeff + num_txt;
    } else {
      num_txt = l_coeff + "*" + num_txt;
    }
  }
  string denom_txt = polynomial_as_txt("denominator", list(list(fraction[2], fraction[3])));

  if(denom_txt == "1")
  {
    s = "(" + num_txt + ")";
  } else {
    s = "(" + num_txt + ")/(" + denom_txt + ")";
  }
  return(s);
}

static proc string_to_poly(string s__)
{
  poly p__;
  execute("p__="+s__);
  return(p__);
}

proc readInputTXT(def file__, list #)
"USAGE:   readInputTXT(file[, mode]), file string, mode int
          readInputTXT(filelist[, mode]), filelist list, mode int
PURPOSE:  read matrix of rational functions from a txt-file and turn it into a
          matrix (i.e. a list of lists) of pairs of polynomials (numerators and
          denominators). The string @code{file} should be the [directory +] name
          of the file in the form \"@code{<path-to-file>/<filename>.txt}\".
       @* The input file should be a list of lists separated by the characters
          \"{\", \"}\" and \",\". Example:
       @* \"{{(x+y)/(x^2-x*y), -(x^2*y+1)/(y), x^2}, {(x+1)/y, y/x, 0}}\"
       @* Each rational function has to be an expression of the form \"a\",
          \"(a)/(b)\", \"(b)^(-n)\" or \"(a)*(b)^(-n)\" where \"a\",\"b\" stand
          for polynomials (i.e. strings, that can be parsed as a polynomial with
          the @code{execute} command) and \"n\" stands for a positive integer. A
          minus sign \"-\" followed by such an expression is also allowed.
       @* IMPORTANT: The strings \"a\",\"b\" must NOT contain the symbol \"/\".
          (So in case the coefficient field is the rationals, all denominators
          in the coefficients of numerator and denominator polynomials should be
          cleared.)
       @* The file should contain less than 2^31 characters (filesize < 2 GB).
          For bigger files the matrix should be split row-wise into multiple
          matrices and saved in different files (each smaller than 2 GB). A list
          of the filenames (in the right order) can then be given as first
          argument instead.
       @* Also the basering has to match the variable names used in the
          input file(s).
       @* @code{mode=1} (default): save result to an ssi-file of the same name
       @* @code{mode=2}: return result
       @* @code{mode=3}: save to ssi-file AND return result
SEE ALSO: pfdMat
"
{
  system("--ticks-per-sec",1000);
  short = 0;
  if(!defined(basering))
    {ERROR("no basering defined!");}
  int left__,right__,pos1__,mid__,pos2__,tmp__,i__,j__,k__,t__,tt__,depth__;
  int mode__=1;
  if(size(#)>0) {mode__=#[1];}
  if(typeof(file__)=="list") // list of filenames given --> apply function to each
  {                          // file and concatenate the resulting matrices
    int n = size(file__);
    list mat__ = list();
    for(i__=1;i__<=n;i__++)
    {
      dbprint(sprintf("  file %s of %s:",i__,n));
      if(find(file__[i__],".txt")==0) {ERROR("wrong file type, expected txt");}
      printlevel = printlevel+1;
      mat__ = mat__ + readInputTXT(file__[i__],2);
      printlevel = printlevel-1;
    }

    if(mode__==2) {return(mat__);}

    string filename__ = file__[1][1,find(file__[1],".txt")-1];
    dbprint("  saving to file "+filename__+".ssi "); t__ = rtimer;
    write("ssi:w "+filename__+".ssi", mat__);
    dbprint(sprintf("  done! (%s ms)", rtimer-t__));

    if(mode__==3) {return(mat__);}
  }
  if(typeof(file__)!="string")
    {ERROR("wrong type for first argument (expected string or list)");}
  if(find(file__,".txt")==0) {ERROR("wrong file type, expected txt");}

  dbprint("  reading file "); t__=rtimer;
  string data__ = read(":r "+file__);
  dbprint(sprintf("  done! (%s ms)", rtimer-t__));

  dbprint("  processing input "); t__ = rtimer;
  left__ = find(data__,"{");
  right__ = find(data__,"}");
  tmp__ = find(data__,"{",left__+1);
  if(left__<tmp__ && tmp__<right__) {left__ = tmp__;}

  int finished__,n__;
  poly p__,q__;
  list row__,mat__;
  string s__,ss__;
  i__=0;
  while(1)
  {
    i__++;
    tt__ = rtimer;
    row__ = list();
    pos2__ = left__;
    finished__ = 0;
    j__=0;
    while(not finished__)
    {
      j__++;
      s__ = "";

      pos1__ = pos2__+1;
      pos2__ = find(data__,",",pos1__);
      if(pos2__==0 || pos2__>right__)    // end of row
      {
        finished__ = 1;
        pos2__ = right__;
      }
      s__ = data__[pos1__,pos2__-pos1__];
      mid__ = find(s__,"/");
      if(mid__==0)
      {
        tmp__ = find(s__,"^(-");
        if(tmp__==0)    //no denominator
        {
          execute("p__=" + s__);
          q__=1;
          row__[j__] = list(p__,q__);
          continue;
        }
        else    // denominator is given by a negative exponent
        {
          if(find(s__,"^(-",tmp__+1)>0)
            {ERROR(sprintf("invalid syntax in (%s,%s)-th entry:"
                              +" more than one negative exponent",i__,j__));}
          for(k__=tmp__+3; s__[k__]!=")"; k__++) {}
          execute("n__=" + s__[tmp__+3,k__-tmp__-3]);
          while(k__<size(s__))
          {
            k__++;
            if(s__[k__]!=" ")
            {ERROR(sprintf("invalid syntax in (%s,%s)-th entry",i__,j__));}
          }
          s__ = s__[1,tmp__-1];
          depth__=0;
          for(k__=tmp__-1; 1; k__--)
          {
            ss__ = s__[k__];
            if(ss__ == ")") {depth__++;}
            else{if(ss__ == "(") {depth__--;}}
            if(depth__==0) {break;}
          }
          if(k__>1)
          {
            while(1)
            {
              if(k__==0)
                {ERROR(sprintf("invalid syntax in (%s,%s)-th entry",i__,j__));}
              k__--;
              ss__ = s__[k__];
              if(ss__=="*" || ss__==" " || ss__=="-") {break;}
            }
          }
          s__ = s__[1,k__] + "1/" + s__[k__+1,size(s__)-k__] + "^" + string(n__);
          mid__ = k__+2;    // position of the character "/"
        }
      }
      if(find(s__,"/",mid__+1)>0)
        {ERROR(sprintf("invalid syntax in (%s,%s)-th entry:%n"
        +"no '/' allowed in the string representing the polynomials",i__,j__,0));}

      execute("p__=" + fixBrackets(s__[1,mid__-1]));
      execute("q__=" + fixBrackets(s__[mid__+1,size(s__)-mid__]));

      row__[j__] = list(p__,q__);
    }
    mat__[i__] = row__;    // append row to matrix
    dbprint(sprintf("    row %s done! (%s ms)",i__,rtimer-tt__));

    left__ = find(data__,"{",right__);
    if(left__==0) {break;}
    right__ = find(data__,"}",left__);
  }
  dbprint(sprintf("  done! (%s ms)", rtimer-t__));

  if(mode__==2) {return(mat__);}

  string filename__ = file__[1,find(file__,".txt")-1];
  dbprint("  saving to file "+filename__+".ssi "); t__ = rtimer;
  write("ssi:w "+filename__+".ssi", mat__);
  dbprint(sprintf("  done! (%s ms)", rtimer-t__));

  if(mode__==3) {return(mat__);}
}

static proc fixBrackets(string data)
{
  int pos=0;
  int left_brackets =0;
  int right_brackets=0;
  int n=size(data);
  while(pos<n)
  {
    pos = find(data,"(",pos+1);
    if(pos==0) {break;}
    left_brackets++;
  }
  pos=0;
  while(pos<n)
  {
    pos = find(data,")",pos+1);
    if(pos==0) {break;}
    right_brackets++;
  }
  int difference = left_brackets-right_brackets;
  if(difference>0)
  {
    for(int i=1; i<=difference; i++) {data = data+")";}
  }
  if(difference<0)
  {
    for(int i=1; i<=-difference; i++) {data = "("+data;}
  }
  return(data);
}

static proc pfdWrap(poly f, def g, int i, int j, link logfile, int output_mode, int decomp_mode)
{
  system("--ticks-per-sec",1000);
  if(output_mode>3)
    {write("ssi:w pfd_results_"+string(i)+"_"+string(j)
           +".ssi","task started, but not finished yet");}
  int t0 = rtimer;
  if(decomp_mode==1) {list result = leinartas_adapted(f,g);}
  else{if(decomp_mode==2) {list result = MultivariateApart_kl(f,g);}
  else {ERROR("wrong decomposition mode");}}
  fprintf(logfile,"_[%s,%s]: %s ms",i,j,rtimer-t0);
  if(output_mode>3)
    {write("ssi:w pfd_results_"+string(i)+"_"+string(j)+".ssi",result);}
  return(result);
}

static proc testEntry(int i, int j, list fraction, list dec, link logfile, int N);
{
  int t=rtimer;
  system("--ticks-per-sec",1000);
  int result = checkpfd(fraction,dec,N);
  if(result==1) {fprintf(logfile, " _[%s,%s]: correct (%s ms)",i,j,rtimer-t);}
  else          {fprintf(logfile, " _[%s,%s]: WRONG! (%s ms)", i,j,rtimer-t);}
  return(result);
}

proc pfdMat(def infile, list #)
"USAGE:   pfdMat(file[, dotest, ignore_nonlin, output_mode, parallelize, decomp_mode]);
          file string, dotest,ignore_nonlin,output_mode,parallelize,decomp_mode int
PURPOSE:  apply @code{leinartas_adapted} to all entries of a matrix of rational functions
          saved in a txt-file. The string @code{file} should be the
          [directory +] name of the file.
       @* The input file can either be a txt-file or an ssi-file created with
          @code{readInputTXT}. In case of a txt-file, the base ring has to match
          and the matrix has to be in the same format specified in
          @ref{readInputTXT}. Also, txt-files that are bigger than 2 GB should
          be split as described for @code{readInputTXT} and a list of the
          filenames can be given as first argument instead.
       @* The result is saved in multiple txt- (and ssi-) files (see below)
          within the directory of the input file.
       @* Also a logfile is created, which protocols the memory used and the
          runtimes of @code{leinartas_adapted} for each matrix entry in real-time.

       @* There are also 5 optional arguments:
       @* If @code{dotest} is nonzero, test the results with checkpfd:
       @* @code{dotest<0} (default): exact test (may be slow),
       @* @code{dotest>0}: do this amount of probabilistic tests for each entry
                           (see @ref{checkpfd}).

       @* If @code{ignore_nonlin} is nonzero (default), for each denominator,
          the nonlinear factors in the factorization are removed before applying
          @code{leinartas_adapted} (and added back in in the output files).

       @* If @code{parallelize} is nonzero (default), the decompositions are
          calculated in parallel using @ref{parallel_lib}.

       @* The parameter @code{output_mode} controls the output files created:
       @* @code{output_mode=1} (default): The result consists of two files:
          @code{<filename>_pfd_indexed.txt} contains the matrix of all
          decompositions (as list of lists separated by the characters \"{\",
          \"}\" and \",\") where all the denominators are written in factorized
          form depending on irreducible factors @code{q1}, @code{q2}, ... .
          The file @code{<filename>_denominator_factors.txt} lists all the
          polynomials @code{q1}, @code{q2}, ... .
       @* @code{output_mode=2}: Additionally to mode 1, the file
          @code{<filename>_pfd.txt} is created, which also contains the matrix
          of decompositions but the factors in the denominators are written out.
       @* @code{output_mode=3}: Additionally to mode 2, the result and some
          intermediate results are saved as SINGULAR objects in ssi-files:
       @* @code{<filename>.ssi}: contains the result of @code{readInputTXT} in
          case a txt-file was given as input.
       @* @code{<filename>_factorized_denominators.ssi}: like the first file,
          but the denominators are saved in factorized form, that is as a list
          of an ideal of irreducible non constant polynomials and an intvec of
          exponents.
       @* @code{<filename>_linear_part.ssi} (only if @code{ignore_nonlin} is
          nonzero): like the previous file, but all the irreducible denominator
          factors are removed
       @* @code{<filename>_non_linear_factors.ssi} (only if @code{ignore_nonlin}
          is nonzero): a list of an ideal @code{p} generated by irreducible
          polynomials and a matrix (list of lists) of the nonlinear denominator
          factors of each entry of the input matrix. These are represented as
          lists of an intvec of indices @code{i} for which @code{p[i]} occurs
          as a (nonlinear) factor in the denominator and an intvec containing
          the exponents of those factors.
       @* @code{<filename>_pfd.ssi}: a list, where the first entry is an ideal
          @code{q} of denominator factors and the second entry is a matrix (as
          list of lists) containing the decompositions, each of which is a list
          of terms, where a term is represented as in the result of @ref{leinartas_adapted}
          by a list containing
       @* 1) the numerator polynomial
       @* 2) an intvec of indices @code{i} for which @code{q[i]} occurs
             as a factor in the denominator
       @* 3) an intvec containing the exponents of those irreducible factors.
       @* IMPORTANT: If @code{ignore_nonlin} is nonzero, this file contains the
          decompositions of the entries of the matrix in
          @code{<filename>_linear_part.ssi}. Thus the nonlinear factors, are
          NOT contained in this file.
       @* @code{output_mode=4}: Additionally to mode 3, the direct output of
          each call of @code{leinartas_adapted} is saved in separate ssi-files called
          @code{pfd_results_i_j.ssi} where i,j are the matrix indices. This
          creates a lot of files, but may be useful in case the algorithm does
          not terminate in time for every matrix entry. Other than the files
          created in mode 1-3, these files are saved in the current directory,
          rather than the directory of the input file.

       @* Lastly @code{decomp_mode} determines, which algorithm is used for the
          decomposition:
          @code{decomp_mode=1} (default): @ref{leinartas_adapted} (improved Leinartas Algorithm from
            'IBP reduction coefficients made simple')
          @code{decomp_mode=2}: @ref{MultivariateApart_kl} (algorithm from 'MultivariateApart:
            Generalized Partial Fractions')
SEE ALSO: readInputTXT, leinartas_adapted, MultivariateApart_kl, checkpfd, checkpfdMat
"
{
  system("--ticks-per-sec",1000);
  short = 0;
  int dotest,ignore_nonlin,output_mode,parallelize,decomp_mode = -1,1,1,1,1;
  if(size(#)>0) {dotest = #[1];}
  if(size(#)>1) {ignore_nonlin = #[2];}
  if(size(#)>2) {output_mode = #[3];}
  if(size(#)>3) {parallelize = #[4];}
  if(size(#)>4) {decomp_mode = #[5];}

  int i,j,k,l,ind;
  list arguments,results;

  dbprint(newline+"reading data "); int t0=rtimer;

  if(typeof(infile)=="list")
  {
    printlevel = printlevel+1;
    if(output_mode>2) {list mat = readInputTXT(infile,3);}
    else {list mat = readInputTXT(infile,2);}
    printlevel = printlevel-1;
    int pos=find(infile[1],".txt");
    string filename = infile[1][1,pos-1];
  }
  else
  {
    int pos=find(infile,".txt");
    if(pos!=0)
    {
      printlevel = printlevel+1;
      if(output_mode>2) {list mat = readInputTXT(infile,3);}
      else {list mat = readInputTXT(infile,2);}
      printlevel = printlevel-1;
    }
    else
    {
      pos=find(infile,".ssi");
      if(pos!=0) {list mat = read("ssi:r "+infile);}
      else {ERROR("invalid file type, expected ssi or txt");}
    }
    string filename = infile[1,pos-1];
  }

  link qfile = ":w "+filename+"_denominator_factors.txt";
  int n = size(mat);
  int m = size(mat[1]);
  dbprint(sprintf("done! (%s ms)",rtimer-t0));

  if(typeof(mat[1][1][2])!="list")    // denominators are not yet factorized
  {
    dbprint("factorizing the denominators "); t0=rtimer;
    printlevel = printlevel+1;
    mat = FactDenom(mat);
    printlevel = printlevel-1;
    if(output_mode>2)
      {write("ssi:w "+filename+"_factorized_denominators.ssi",mat);}
    dbprint(sprintf("done! (%s ms)",rtimer-t0));
  }

  if(ignore_nonlin)
  {
    dbprint("removing nonlinear denominator factors before leinartas_adapted is applied");
    list nonlin_denom_factors;
    ideal p;
    printlevel = printlevel+1;
    mat, nonlin_denom_factors, p = removeNonlinearFactors(mat, filename);
    printlevel = printlevel-1;
    if(output_mode>2)
    {
      dbprint("saving nonlinear factors to "+filename+"_non_linear_factors.ssi ");
      t0 = rtimer;
      write("ssi:w "+filename+"_non_linear_factors.ssi", list(p,nonlin_denom_factors));
      dbprint(sprintf("done! (%s ms)",rtimer-t0));
      dbprint("saving input matrix without the nonlinear factors to "
              +filename+"_linear_part.ssi ");
      t0 = rtimer;
      write("ssi:w "+filename+"_linear_part.ssi", mat);
      dbprint(sprintf("done! (%s ms)",rtimer-t0));
    }
  }

  if(parallelize)
  {
    dbprint("creating tasks "); t0=rtimer;
    write(":w "+filename+"_pfdMat_logfile.txt","finished matrix entries with runtimes "
          +"(calculated in parallel on "+string(getcores())+" cores):");
    link logfile = ":a "+filename+"_pfdMat_logfile.txt";
    for(i=1; i<=n; i++)
    {
      for(j=1; j<=m; j++)
      {
        ind = m*(i-1)+j;
        arguments[ind] = list(mat[i][j][1],mat[i][j][2],i,j,logfile,output_mode,decomp_mode);
      }
    }
    dbprint(sprintf("done! (%s ms)",rtimer-t0));

    dbprint("applying pfd to each matrix entry "); t0 = rtimer;
    results = parallelWaitAll("pfdWrap",arguments);
    arguments = list();
    dbprint(sprintf("done! (%s ms)",rtimer-t0));

    write(logfile,"decomposition: "+string(rtimer-t0)+" ms and "+string(memory(2))
                   +" Byte Memory max. (after calling leinartas_adapted on each matrix entry)");

    dbprint("writing results in matrix shape "); t0 = rtimer;
    list dec_mat;
    for(i=1; i<=n; i++)
    {
      dec_mat[i] = list();
      for(j=1; j<=m; j++)
      {
        ind = m*(i-1)+j;
        dec_mat[i][j] = results[ind];
      }
    }
    results = list();
    dbprint(sprintf("done! (%s ms)",rtimer-t0));
  }
  else
  {
    dbprint("applying leinartas_adapted to each matrix entry "); t0=rtimer;
    write(":w "+filename+"_pfdMat_logfile.txt",
          "finished matrix entries with runtimes (no parallelization):");
    link logfile = ":a "+filename+"_pfdMat_logfile.txt";
    list dec_mat;
    for(i=1; i<=n; i++)
    {
      dec_mat[i] = list();
      for(j=1; j<=m; j++)
      {
        dec_mat[i][j] = pfdWrap(mat[i][j][1],mat[i][j][2],i,j,logfile,output_mode,decomp_mode);
      }
    }
    dbprint(sprintf("done! (%s ms)",rtimer-t0));
    write(logfile,"decomposition: "+string(rtimer-t0)+" ms and "+string(memory(2))
          +" Byte Memory max. (after calling leinartas_adapted on each matrix entry)");
 }

  dbprint("making one single list of denominator factors "); t0 = rtimer;
  ideal q,new_q;
  intvec dict;
  for(i=1; i<=n; i++)
  {
    for(j=1; j<=m; j++)
    {
      new_q = dec_mat[i][j][1];
      dec_mat[i][j] = dec_mat[i][j][2];
      dict = 0:0;
      for(k=1; k<=size(new_q); k++)
      {
        ind = find_entry(q,new_q[k]);
        if(ind==0)
        {
          ind = size(q)+1;
          q[ind] = new_q[k];
        }
        dict[k] = ind;
      }
      for(k=1; k<=size(dec_mat[i][j]); k++)
      {
        if(size(dec_mat[i][j][k][2])>0)
          {dec_mat[i][j][k][2] = intvec(dict[dec_mat[i][j][k][2]]);}
      }
    }
    dbprint(sprintf("  row %s complete!",i));
  }
  dbprint(sprintf("done! (%s ms)",rtimer-t0));

  if(output_mode>2)
  {
    dbprint("saving result to "+filename+"_pfd.ssi "); t0 = rtimer;
    write("ssi:w "+filename+"_pfd.ssi", list(q,dec_mat));
    dbprint(sprintf("done! (%s ms)",rtimer-t0));
  }

  if(ignore_nonlin)
  {
    ind = size(q);
    for(i=1; i<=size(p); i++) {q[ind+i]=p[i];} // add nonlin. polynomials to q
    for(i=1; i<=n; i++)
    {
      for(j=1; j<=m; j++)
      {
        nonlin_denom_factors[i][j][1] = nonlin_denom_factors[i][j][1]+ind; // adjust indices
      }
    }
  }

  if(ignore_nonlin)
    {dbprint(sprintf("creating readable .txt-files (including the nonlinear factors again)"));}
  else
    {dbprint(sprintf("creating readable .txt-files "));}
  t0 = rtimer;
  dbprint(" indexed ("+filename+"_pfd_indexed.txt):");
  printlevel = printlevel+1;
  if(ignore_nonlin)
    {saveResultTXT_indexed(dec_mat, filename+"_pfd_indexed", nonlin_denom_factors);}
  else {saveResultTXT_indexed(dec_mat, filename+"_pfd_indexed");}
  printlevel = printlevel-1;
  for(i=1; i<=size(q); i++) {fprintf(qfile, "q%s = %s;", i, q[i]);}
  if(output_mode>1)
  {
    dbprint(" denominators written out ("+filename+"_pfd.txt):");
    printlevel = printlevel+1;
    if(ignore_nonlin)
      {saveResultTXT(dec_mat, q, filename+"_pfd", nonlin_denom_factors);}
    else {saveResultTXT(dec_mat, q, filename+"_pfd");}
    printlevel = printlevel-1;
  }
  dbprint(sprintf("done! (%s ms)",rtimer-t0));

  if(dotest)
  {
    if(dotest<0)
      {dbprint("checking for correctness (exact test) ");}
    else
      {dbprint(sprintf("checking for correctness (%s random evaluations per entry) ",dotest));}
    t0 = rtimer;
    if(parallelize)
    {
      for(i=1; i<=n; i++)
      {
        for(j=1; j<=m; j++)
        {
          arguments[m*(i-1)+j]=list(i,j,mat[i][j],list(q,dec_mat[i][j]),logfile,dotest);
        }
      }
      results = parallelWaitAll("testEntry",arguments);
    }
    else
    {
      for(i=1; i<=n; i++)
      {
        for(j=1; j<=m; j++)
        {
          results[m*(i-1)+j]=testEntry(i,j,mat[i][j],list(q,dec_mat[i][j]),logfile,dotest);
        }
      }
    }
    dbprint(sprintf("%s out of %s = %sx%s decompositions are correct! (%s ms)%n",
            sum(results),n*m,n,m,rtimer-t0,0));
    write(logfile,"checking for correctness: "+string(rtimer-t0)+" ms and "
          +string(memory(2))+" Byte Memory max. (at the end of pfdMat), "
          +string(sum(results))+" correct out of "+string(n*m));
  }
}

static proc FactDenom(list mat)
{
  system("--ticks-per-sec",1000);
  int i,j,k,ind,t,counter;
  int n = size(mat);
  int m = size(mat[1]);
  list denom = list();
  for(i=1; i<=n; i++)
  {
    denom[i] = list();
    for(j=1; j<=m; j++)
    {
      denom[i][j] = mat[i][j][2];
      mat[i][j][2] = list(ideal(),intvec(0:0));
    }
  }
  int expon;
  list fact;
  number lcoeff;
  int timeout = 60000;
  int finished = 0;
  list arguments,results;
  ideal q;
  while(!finished)
  {
    t = rtimer;
    for(i=1; i<=n; i++)   // create argument list
    {
      for(j=1; j<=m; j++)
        {arguments[m*(i-1)+j] = list(denom[i][j]);}
    }

    results = parallelWaitAll("factorize",arguments,timeout);
    arguments = list();

    for(i=1; i<=n; i++)   // update q, mat, denom
    {
      for(j=1; j<=m; j++)
      {
        ind = m*(i-1)+j;
        if(typeof(results[ind]) != "none")
        {
          fact = results[ind];
          for(k=2; k<=size(fact[1]); k++)
          {
            lcoeff = leadcoef(fact[1][k]);
            fact[1][k] = fact[1][k]/lcoeff;
            fact[1][1] = fact[1][1]*(lcoeff^fact[2][k]); // polynomial is monic (thus unique)
            lcoeff = content(fact[1][k]);
            fact[1][k] = fact[1][k]/lcoeff;
            fact[1][1] = fact[1][1]*(lcoeff^fact[2][k]); // polynomial has nice coefficients

            // add a new factor to q:
            ind = find_entry(q,fact[1][k]);
            if(ind==0) {q[size(q)+1] = fact[1][k];}
            // complete the factorization of the i,j-th denominator:
            ind = find_entry(mat[i][j][2][1],fact[1][k]);
            if(ind==0)
            {
              ind = size(mat[i][j][2][1])+1;
              mat[i][j][2][1][ind] = fact[1][k];
              mat[i][j][2][2][ind] = fact[2][k];
            }
            else
            {
              mat[i][j][2][2][ind] = mat[i][j][2][2][ind] + fact[2][k];
            }
          }
          mat[i][j][1] = mat[i][j][1]/fact[1][1];
          denom[i][j] = 1;
        }
      }
    }
    results = list();

    finished = 1;
    counter = n*m;
    for(i=1; i<=n; i++) // factorize by any known factors (from q)
    {
      for(j=1; j<=m; j++)
      {
        for(k=1; k<=size(q); k++)
        {
          expon=0;
          while(reduce(denom[i][j],q[k])==0)
          {
            denom[i][j] = denom[i][j]/q[k];
            expon++;
          }
          if(expon>0)
          {
            ind = size(mat[i][j][2][1])+1;
            mat[i][j][2][1][ind] = q[k];
            mat[i][j][2][2][ind] = expon;
          }
        }
        if(deg(denom[i][j])==0)
        {
          mat[i][j][1] = mat[i][j][1]/denom[i][j];
          denom[i][j] = poly(1);
        }
        if(denom[i][j]!=poly(1)) {finished = 0; counter--;}
      }
    }
    timeout = timeout*2;
    dbprint(sprintf("  %s out of %s denominators factorized completely (%s ms)",
                                                         counter,n*m,rtimer-t));
  }
  return(mat);
}

static proc saveResultTXT_indexed(list dec, string filename, list #)
{
  // expect dec = list(list(dec11, dec12, ...), list(dec21, dec22, ...), ...),
  // where dec11, dec12, ... are decompositions of form list(list(poly, intvec, intvec), ...)
  system("--ticks-per-sec",1000);
  list nonlinFactors = list();
  if(size(#)>0) {nonlinFactors = #;}
  link file = ":w "+filename+".txt";

  int i,j;
  int t;
  string s="{";
  int n=size(dec);
  int m=size(dec[1]);
  int k;
  for(i=1; i<=n; i++)
  {
    t = rtimer;
    s = s+"{";
    for(j=1; j<=m; j++)
    {
      if(size(nonlinFactors)>0)
      {
        if(size(nonlinFactors[i][j][1])>0)
        {
          s = s + getStringFraction_indexed(list(poly(1))+nonlinFactors[i][j])
                + " * (" + getStringpfd_indexed(dec[i][j]) + "), ";
          j++; continue;
        }
      }
      s = s + getStringpfd_indexed(dec[i][j]) + ", ";
    }
    k = size(s);
    s[k-1] = "}"; s[k] = ","; s = s+" ";
    dbprint(sprintf("  row %s done! (%s ms)",i,rtimer-t));
  }
  k = size(s);
  s[k-1] = "}"; s[k] = " ";
  write(file,s);
}

static proc saveResultTXT(list dec, ideal q, string filename, list #)
{
  // expect dec = list(list(dec11, dec12, ...), list(dec21, dec22, ...), ...),
  // where dec11, dec12, ... are decompositions of form list(list(poly, intvec, intvec), ...)
  system("--ticks-per-sec",1000);
  list nonlinFactors = list();
  if(size(#)>0) {nonlinFactors = #;}
  link file = ":w "+filename+".txt";

  int i,j;
  int t;
  string s="{";
  int n=size(dec);
  int m=size(dec[1]);
  int k;
  for(i=1; i<=n; i++)
  {
    t = rtimer;
    s = s+"{";
    for(j=1; j<=m; j++)
    {
      if(size(nonlinFactors)>0)
      {
        if(size(nonlinFactors[i][j][1])>0)
        {
          s = s + getStringFraction(list(poly(1))+nonlinFactors[i][j],q)
                + " * (" + getStringpfd(list(q,dec[i][j])) + "), ";
          j++; continue;
        }
      }
      s = s + getStringpfd(list(q,dec[i][j])) + ", ";
    }
    k = size(s);
    s[k-1] = "}"; s[k] = ","; s = s+" ";
    dbprint(sprintf("  row %s done! (%s ms)",i,rtimer-t));
  }
  k = size(s);
  s[k-1] = "}"; s[k] = " ";
  write(file,s);
}

static proc removeNonlinearFactors(list fractions, string filename)
{
  int n=size(fractions);
  int m=size(fractions[1]);
  int i,j,k,t0,ind;
  ideal p;
  list nonlin_denom_factors;
  intvec factors,exponents;
  list fac;
  for(i=1; i<=n; i++)
  {
    t0 = rtimer;
    nonlin_denom_factors[i] = list();
    for(j=1; j<=m; j++)
    {
      fac = fractions[i][j][2];
      factors = 0:0;
      exponents = 0:0;
      for(k=1; k<=size(fac[1]); k++)
      {
        if(deg(poly(fac[1][k]))>1)
        {
          // add the nonlin. factor fac[1][k] to p if necessary:
          if(size(p)==0) {ind = 1; p[ind]=fac[1][k];}
          else
          {
            for(ind=1;1;ind++)
            {
              if(p[ind]==fac[1][k]) {break;}
              if(ind==size(p))
              {
                ind++;
                p[ind]=fac[1][k];
                break;
              }
            }
          }
          factors[size(factors)+1] = ind;
          exponents[size(exponents)+1] = fac[2][k];
          fac[1] = delete(fac[1],k);
          fac[2] = delete(fac[2],k);
          continue;
        }
      }
      fractions[i][j][2] = fac;
      nonlin_denom_factors[i][j] = list(factors,exponents);
    }
    dbprint(sprintf("  row %s done! (%s ms)", i, rtimer-t0));
  }
  return(fractions, nonlin_denom_factors, p);
}

proc checkpfdMat(def input, string output, string qfile, list #)
"USAGE:   checkpfdMat(input, output, denomFactors[, N, parallelize]);
          input,output,denomFactors string, N,parallelize int
PURPOSE:  test the output files of @code{pfdMat} for correctness. Input and
          output (indexed) txt-files have to be given as strings in the form
          \"@code{<path-to-file>/<filename>.txt}\". The output should be indexed
          (that is the output file ending in @code{..._pfd_indexed.txt}) and
          @code{denomFactors} has to be the file containing the denominator
          factors @code{q1}, @code{q2}, ... (the txt-file ending in
          @code{..._denominator_factors.txt}).
       @* As for @code{readInputTXT} and @code{pfdMat}, the basering has to
          match the variable names used in the input file, which has to be in
          the same format specified in @ref{readInputTXT}. Also, files bigger
          than 2 GB have to be split as described for @code{readInputTXT} and a
          list of filenames can be given as first argument instead.
       @* If a positive integer N is given, the test is done probabilistically by
          evaluation at N random points for each entry of the matrix. If N is
          nonpositive (default), the fractions in the decompositions will be
          expanded symbolically and compared to the input (may be slower).
       @* If @code{parallelize} is nonzero (default), the tests are run in
          parallel using @ref{parallel_lib}.
       @* The result is printed and as in @code{pfdMat} a logfile is created
          showing the results for each matrix entry.
SEE ALSO: readInputTXT, leinartas_adapted, checkpfd, pfdMat
"
{
  system("--ticks-per-sec",1000);
  short = 0;
  int t0;
  int N=0;
  int parallelize=1;
  if(size(#)==1)
  {
    if(typeof(#[1])=="int") {N=#[1];}
    else {ERROR("invalid argument type: "+typeof(#[1]));}
  }
  if(size(#)==2)
  {
    if(typeof(#[1])=="int" && typeof(#[2])=="int")
      {N=#[1]; parallelize=#[2];}
    else {ERROR("invalid argument types: "+typeof(#[1])+", "+typeof(#[2]));}
  }
  if(size(#)>2) {ERROR("too many arguments");}

  dbprint(newline+"reading input file:");
  printlevel = printlevel+1;
  list frac = readInputTXT(input,2);
  printlevel = printlevel-1;
  if(typeof(input)=="string") {string filename=input;}
  if(typeof(input)=="list")   {string filename=input[1];}
  filename = filename[1,find(filename,".txt")-1];

  dbprint("factorizing the denominators "); t0=rtimer;
  printlevel = printlevel+1;
  frac = FactDenom(frac);
  printlevel = printlevel-1;
  dbprint(sprintf("done! (%s ms)",rtimer-t0));

  dbprint("reading output files:"); t0=rtimer;
  dbprint(" reading list of denominator factors from "+qfile);
  ideal q;
  q = readQfileTXT(qfile);
  dbprint(" done!");

  dbprint(" reading (indexed) output decompositions ");
  list dec,nonlin;
  printlevel = printlevel+1;
  dec,nonlin = readOutputTXT_indexed(output);
  printlevel = printlevel-1;

  if(parallelize)
    {dbprint(sprintf("done! (%s ms)%n%ncreating tasks",rtimer-t0,0)); t0=rtimer;}
  else
  {
    dbprint(sprintf("done! (%s ms)%n",rtimer-t0,0));
    if(N<=0)
      {dbprint("checking for correctness (exact test) ");}
    else
      {dbprint(sprintf("checking for correctness (%s random evaluations per entry) ",N));}
    t0=rtimer;
  }

  fprintf(":w "+filename+"_checkpfdMat_logfile.txt","Input file (matrix of rational functions):"
          +" %s%nOutput file (decompositions): %s%nlist of all denominator factors:"
          +" %s%n%nResults of checkpfdMat:",input,output,qfile,0);
  link logfile = ":a "+filename+"_checkpfdMat_logfile.txt";

  int n=size(frac);
  int m=size(frac[1]);
  int i,j,k,ind;
  list arguments;
  for(i=1;i<=n;i++)
  {
    for(j=1;j<=m;j++)
    {
      for(k=1;k<=size(nonlin[i][j][1]);k++)
      {
        ind = find_entry(frac[i][j][2][1],q[nonlin[i][j][1][k]]);
        if(ind==0) {ERROR("nonlinear factors are wrong");}
        if(frac[i][j][2][2][ind]!=nonlin[i][j][2][k])
          {ERROR("nonlinear factors are wrong");}
        frac[i][j][2][1] = delete(frac[i][j][2][1],ind);
        frac[i][j][2][2] = delete(frac[i][j][2][2],ind);
      }
      if(parallelize)
        {arguments[(i-1)*m+j] = list(i,j,frac[i][j],list(q,dec[i][j]),logfile,N);}
      else
        {results[(i-1)*m+j] = testEntry(i,j,frac[i][j],list(q,dec[i][j]),logfile,N);}
    }
  }

  if(parallelize)
  {
    dbprint(sprintf("done! (%s ms)%n",rtimer-t0,0));
    if(N<=0)
      {dbprint("checking for correctness (exact test) ");}
    else
      {dbprint(sprintf("checking for correctness (%s random evaluations per entry) ",N));}
    t0=rtimer;
    list results = parallelWaitAll("testEntry",arguments);
  }
  else {dbprint(sprintf("done! (%s ms)",rtimer-t0));}
  dbprint(sprintf("%s out of %s = %sx%s decompositions are correct! (%s ms)%n",
          sum(results),n*m,n,m,rtimer-t0,0));
  fprintf(logfile,"%s out of %s = %sx%s decompositions are correct! (%s ms)%n",
          sum(results),n*m,n,m,rtimer-t0,0);
}

static proc readOutputTXT_indexed(string filename__)
{
  system("--ticks-per-sec",1000);
  dbprint("  reading matrix of decompositions from file "+filename__);
  int t__=rtimer;
  int tt__;
  string data__ = read(":r "+filename__);
  dbprint(sprintf("  done! (%s ms)", rtimer-t__));

  dbprint("  processing input "); t__ = rtimer;
  list mat__;
  list nonlin__=list();
  int left__,right__=0,0;
  left__ = find(data__,"{");
  int pos1__,pos2__=0,0;
  int p1__,p2__;
  int tmp__,tmp2__,depth__;
  int i__,j__,k__,l__,max__;
  intvec factors__,exponents__;
  poly numerator__;
  string s__,ss__;
  for(i__=1;1;i__++)
  {
    tt__ = rtimer;
    left__ = find(data__,"{",left__+1);
    if(left__==0) {break;}
    right__ = find(data__,"}",left__);
    mat__[i__]=list();
    nonlin__[i__]=list();
    pos2__=left__;
    for(j__=1;pos2__<right__&&pos2__>0;j__++)
    {
      pos1__ = pos2__+1;
      pos2__ = find(data__,",",pos1__);
      if(pos2__==0||pos2__>right__) {s__ = data__[pos1__,right__-pos1__];}
      else {s__ = data__[pos1__,pos2__-pos1__];}
      mat__[i__][j__] = list();

      factors__ = intvec(0:0);
      exponents__ = intvec(0:0);
      l__ = find(s__," * ");
      if(l__>0)
      {
        ss__ = s__[1,l__-1];    //ss__ contains the nonlinear factors
        s__ = s__[l__+3,size(s__)-l__-2];
        for(p1__=1;s__[p1__]!="(";p1__++) {}
        for(p2__=size(s__);s__[p2__]!=")";p2__--) {}
        s__ = s__[p1__+1,p2__-p1__-1];
        l__ = find(ss__,"q");
        ss__ = ss__[l__,find(ss__,")",l__)-l__];
        ss__ = ss__+"*";
        p1__=0;
        for(l__=1;1;l__++)
        {
          p1__ = find(ss__,"q",p1__+1);
          if(p1__==0) {break;}
          p1__++;
          p2__ = find(ss__,"^",p1__);
          tmp__ = find(ss__,"*",p1__);
          if((p2__>tmp__ && tmp__>0) || (p2__==0))    //exponent is 1
          {
            execute("factors__[l__]="+ss__[p1__,tmp__-p1__]);
            exponents__[l__] = 1;
          }
          else
          {
            execute("factors__[l__]="+ss__[p1__,p2__-p1__]);
            execute("exponents__[l__]="+ss__[p2__+1,tmp__-p2__-1]);
          }
        }
      }
      nonlin__[i__][j__] = list(factors__,exponents__);

      depth__ = 0;
      s__=s__+" ";
      max__ = size(s__);
      tmp__ = 1;
      tmp2__ = 0;
      for(k__=1;k__<=max__;k__++)
      {
        if(s__[k__]=="(") {depth__++;k__++;continue;}
        if(s__[k__]==")") {depth__--;k__++;continue;}
        if(s__[k__]=="/" && depth__==0) {tmp2__ = k__;}
        if((s__[k__]=="+" && depth__==0) || k__==max__)
        {
          if(tmp2__==0)    // no denominator
          {
            execute("numerator__="+s__[tmp__,k__-tmp__]);
            mat__[i__][j__][size(mat__[i__][j__])+1] = list(numerator__,intvec(0:0),intvec(0:0));
            tmp__ = k__+1;
            k__++; continue;
          }
          execute("numerator__="+s__[tmp__,tmp2__-tmp__]);
          ss__ = s__[tmp2__+1,k__-tmp2__-1];
          p1__ = find(ss__,"(");
          p2__ = find(ss__,")");
          ss__ = ss__[p1__+1,p2__-p1__-1];   // now ss__ is only the denominator

          ss__ = ss__+"*";
          factors__ = intvec(0:0);
          exponents__ = intvec(0:0);
          p1__=0;
          for(l__=1;1;l__++)
          {
            p1__ = find(ss__,"q",p1__+1);
            if(p1__==0) {break;}
            p1__++;
            p2__ = find(ss__,"^",p1__);
            tmp__ = find(ss__,"*",p1__);
            if((p2__>tmp__ && tmp__>0) || (p2__==0))    //exponent is 1
            {
              execute("factors__[l__]="+ss__[p1__,tmp__-p1__]);
              exponents__[l__] = 1;
            }
            else
            {
              execute("factors__[l__]="+ss__[p1__,p2__-p1__]);
              execute("exponents__[l__]="+ss__[p2__+1,tmp__-p2__-1]);
            }
          }
          mat__[i__][j__][size(mat__[i__][j__])+1] = list(numerator__,factors__,exponents__);
          tmp__ = k__+1;
          tmp2__ = 0;
        }
      }
    }
    dbprint(sprintf("    row %s done! (%s ms)",i__,rtimer-tt__));
  }
  dbprint(sprintf("  done! (%s ms)", rtimer-t__));

  return(mat__,nonlin__);
}

static proc readOutputTXT(string filename__)
{
  system("--ticks-per-sec",1000);
  dbprint("  reading matrix of decompositions from file "+filename__);
  int t__=rtimer;
  int tt__;
  string data__ = read(":r "+filename__);
  dbprint(sprintf("  done! (%s ms)", rtimer-t__));

  dbprint("  processing input "); t__ = rtimer;
  list mat__;
  list nonlin__=list();
  int left__,right__=0,0;
  left__ = find(data__,"{");
  int pos1__,pos2__=0,0;
  int p1__,p2__;
  int tmp__,tmp2__,depth__;
  int i__,j__,k__,l__,max__,ind__;
  ideal q__;
  poly f__;
  intvec factors__,exponents__;
  poly numerator__;
  string s__,ss__;
  for(i__=1;1;i__++)
  {
    tt__ = rtimer;
    left__ = find(data__,"{",left__+1);
    if(left__==0) {break;}
    right__ = find(data__,"}",left__);
    mat__[i__]=list();
    nonlin__[i__]=list();
    pos2__=left__;
    for(j__=1;pos2__<right__&&pos2__>0;j__++)
    {
      pos1__ = pos2__+1;
      pos2__ = find(data__,",",pos1__);
      if(pos2__==0||pos2__>right__) {s__ = data__[pos1__,right__-pos1__];}
      else {s__ = data__[pos1__,pos2__-pos1__];}
      mat__[i__][j__] = list();

      factors__ = intvec(0:0);
      exponents__ = intvec(0:0);
      l__ = find(s__," * ");
      if(l__>0)
      {
        ss__ = s__[1,l__-1];    //ss__ contains the nonlinear factors
        s__ = s__[l__+3,size(s__)-l__-2];
        for(p1__=1;s__[p1__]!="(";p1__++) {}
        for(p2__=size(s__);s__[p2__]!=")";p2__--) {}
        s__ = s__[p1__+1,p2__-p1__-1];

        //l__ = find(ss__,"q");
        //ss__ = ss__[l__,find(ss__,")",l__)-l__];
        for(p2__=size(ss__);ss__[p2__]!=")";p2__--) {}
        l__ = find(ss__,"/(")+2;
        ss__ = ss__[l__,p2__-l__];

        ss__ = ss__+"*";
        p1__=0;
        for(l__=1;1;l__++)
        {
          p1__ = find(ss__,"(",p1__+1);
          if(p1__==0) {break;}
          p1__++;
          p2__ = find(ss__,")",p1__);
          tmp__ = find(ss__,"*",p2__);

          execute("f__="+ss__[p1__,p2__-p1__]);
          ind__ = find_entry(q__,f__);
          if(ind__==0) {ind__=size(q__)+1; q__[ind__]=f__;}
          factors__[l__] = ind__;

          if(tmp__==p2__+1)    //exponent is 1
          {
            exponents__[l__] = 1;
          }
          else {if(ss__[p2__+1]=="^")
          {
            execute("exponents__[l__]="+ss__[p2__+2,tmp__-p2__-2]);
          }
          else {ERROR("Wrong input format");}}
        }
      }
      nonlin__[i__][j__] = list(factors__,exponents__);

      depth__ = 0;
      s__=s__+" ";
      max__ = size(s__);
      tmp__ = 1;
      tmp2__ = 0;
      for(k__=1;k__<=max__;k__++)
      {
        if(s__[k__]=="(") {depth__++;k__++;continue;}
        if(s__[k__]==")") {depth__--;k__++;continue;}
        if(s__[k__]=="/" && depth__==0) {tmp2__ = k__;}
        if((s__[k__]=="+" && depth__==0) || k__==max__)
        {
          if(tmp2__==0)    // no denominator
          {
            execute("numerator__="+s__[tmp__,k__-tmp__]);
            mat__[i__][j__][size(mat__[i__][j__])+1] = list(numerator__,intvec(0:0),intvec(0:0));
            tmp__ = k__+1;
            k__++; continue;
          }
          execute("numerator__="+s__[tmp__,tmp2__-tmp__]);
          ss__ = s__[tmp2__+2,k__-tmp2__-2];
          for(p2__=size(ss__);ss__[p2__]!=")";p2__--) {}
          ss__ = ss__[1,p2__-1];  // now ss__ is only the denominator

          ss__ = ss__+"*";
          factors__ = intvec(0:0);
          exponents__ = intvec(0:0);
          p1__=0;

          /*
          for(l__=1;1;l__++)
          {
            p1__ = find(ss__,"q",p1__+1);
            if(p1__==0) {break;}
            p1__++;
            p2__ = find(ss__,"^",p1__);
            tmp__ = find(ss__,"*",p1__);
            if((p2__>tmp__ && tmp__>0) || (p2__==0))    //exponent is 1
            {
              execute("factors__[l__]="+ss__[p1__,tmp__-p1__]);
              exponents__[l__] = 1;
            }
            else
            {
              execute("factors__[l__]="+ss__[p1__,p2__-p1__]);
              execute("exponents__[l__]="+ss__[p2__+1,tmp__-p2__-1]);
            }
          }
          */

          for(l__=1;1;l__++)
          {
            p1__ = find(ss__,"(",p1__+1);
            if(p1__==0) {break;}
            p1__++;
            p2__ = find(ss__,")",p1__);
            tmp__ = find(ss__,"*",p2__);

            execute("f__="+ss__[p1__,p2__-p1__]);
            ind__ = find_entry(q__,f__);
            if(ind__==0) {ind__=size(q__)+1; q__[ind__]=f__;}
            factors__[l__] = ind__;

            if(tmp__==p2__+1)    //exponent is 1
            {
              exponents__[l__] = 1;
            }
            else {if(ss__[p2__+1]=="^")
            {
              execute("exponents__[l__]="+ss__[p2__+2,tmp__-p2__-2]);
            }
            else {ERROR("Wrong input format");}}
          }


          mat__[i__][j__][size(mat__[i__][j__])+1] = list(numerator__,factors__,exponents__);
          tmp__ = k__+1;
          tmp2__ = 0;
        }
      }
    }
    dbprint(sprintf("    row %s done! (%s ms)",i__,rtimer-tt__));
  }
  dbprint(sprintf("  done! (%s ms)", rtimer-t__));

  return(mat__,nonlin__,q__);
}

static proc readQfileTXT(string filename__)
{
  string data__ = read(":r "+filename__);
  ideal q__;
  int pos1__,pos2__=1,1;
  while(1)
  {
    pos1__=find(data__,"=",pos2__);
    if(pos1__==0) {break;}
    pos1__++;
    pos2__=find(data__,";",pos1__);
    if(pos2__==0)
      {pos2__=find(data__,newline,pos1__);}
    execute("q__[size(q__)+1]="+data__[pos1__,pos2__-pos1__]);
  }
  return(q__);
}

// leinartas_adapted working on single entries given as txt-file /////////////////////////////

proc file_exists(string file)
{
  return(status(":r "+file,"exists","yes"));
}

proc pfdSingleEntry(string filename, list #)
"USAGE:   pfdSingleEntry(filename[,from_dir,to_dir,ignore_nonlin,parallelize,debug]), filename,from_dir,to_dir string,  ignore_nonlin int
PURPOSE:  apply @code{leinartas_adapted} to the rational function saved in a txt-file.
          @code{filename} is the name (no file ending) of a txt-file containing
          the rational function as a string.
          @code{from_dir} and @code{to_dir} are the directories (relative to current
          directory) of the input and output files respectively (default:
          current directory).
       @* First, in @code{from_dir} an ssi-file of the same name is created
          which contains the rational function as a two-element list of
          numerator (as polynomial) and denominator (as list of an ideal of
          factors and an intvec of exponents).
       @* If @code{pfdSingleEntry} is called a second time, this ssi-file (or
          one created with pfdSingleEntrySSI) will be used as input instead.
          If the output files ALL already exist, @code{pfdSingleEntry} will
          abort and NOT do the computation again!
          If a txt-file is used as input, a basering must be created, that
          matches the variable names used in the input file.

       @* If @code{ignore_nonlin} is nonzero (default), nonlinear factors will
          be ignored in the algorithm as described in @ref{pfdMat}.
       @* The result will be safed as 5 txt- and ssi-files:
       @* - the result in indexed and non-indexed form (two .txt-files)
       @* - a list of denominator factors appearing in that rational function (.txt-file)
       @* - a .txt-file documenting runtime and memory usage
       @* - the result as .ssi-file containng the direct output of @ref{leinartas_adapted}
            if @code{ignore_nonlin} is false or a two-element list of the
            nonlinear denominator factors (in factorized form) and the output of
            @ref{leinartas_adapted} (without nonlinear denominator factors) if
            @code{ignore_nonlin} is true.

       @* If @code{parallelize} is nonzero (default: 0), @code{pfdParallel} will
          be used instead of @code{leinartas_adapted}.
       @* If @code{debug} is nonzero (default: 0), a logfile will be created as
          in @ref{leinartas_adapted}.
SEE ALSO: leinartas_adapted, pfdParallel, pfdMat, pfdSingleEntrySSI
"
{
  system("--ticks-per-sec",1000);
  short = 0;

  list args = parsePfdSingleEntryArgs(#);
  string from_dir = args[1];
  string to_dir = args[2];
  string pfd_implementation = args[3];
  int ignore_nonlin = args[4];
  intvec steps = args[5];
  int save_int_res = args[6];
  int parallelize = args[7];
  string input_format = args[8]; //"ssi" or "listnumden"
  string output_format = args[9]; //"ssi" or "listnumden" or "cleartext" or "indexed_denominator" or "indexed_numerator_denominator"


  int i,j,k;
  list fraction;
  i = find(filename,".");
  if(i>0) {filename = filename[1,i-1];} // remove file ending if given

  if(file_exists(to_dir+"result_"+filename+".ssi")) {return();}

  prepareSingleEntryFraction( filename
                            , from_dir
                            );

  fraction = read("ssi:r "+from_dir+filename+".ssi");
  list nonlin = prepareNonLin(fraction, ignore_nonlin);
  fraction = nonlin[1];
  nonlin = nonlin[2];

  int t = rtimer;
  int debug = 0;

  list result;
  if(parallelize) {
    result = pfdParallel(fraction);
  } else{if (pfd_implementation == "Leinartas") {
    //format: leinartas_adapted(list(q,terms)[,debug,steps,save_int_res])
    result = leinartas_adapted(fraction, save_int_res, steps, save_int_res);
  } else{if (pfd_implementation == "MultivariateApart") {
    // TODO: check whether the MultivariateApart_kl implementation does not already handle
    // this case.
    list fractioni, resulti, resultq;
    ideal q = fraction[1];
    list terms = fraction[2];
    int index;
    intvec indices;
    intvec powers;

    result[1] = q;
    result[2] = list();

    for (i = 1; i <= size(terms); i++) {
      indices = terms[i][2];
      powers = terms[i][3];
      fractioni[1] = terms[i][1]; // numerator
      fractioni[2] = list();
      fractioni[2][1] = ideal(q[indices]);
      fractioni[2][2] = powers;
      resulti = MultivariateApart_kl(fractioni[1], fractioni[2], save_int_res);


      // need to convert back from q[indices] to q
      // for fractioni, we created a new q, with the ith generator determined by
      // the ith index in indices
      resultq = list();
      for (j = 1; j <= size(resulti[2]); j++) {
        for (k = 1; k <= size(resulti[2][j][2]); k++) {
          index = resulti[2][j][2][k];
          resulti[2][j][2][k] = indices[index];
        }
        resultq[j] = list();
        resultq[j][1] = resulti[2][j][1];
        resultq[j][2] = resulti[2][j][2];
        resultq[j][3] = resulti[2][j][3];
      }
      result[2] = mergepfd(result[2], resultq);
    }
  } else {
    ERROR(pfd_implementation + " not implemented");
  }}}

  t = rtimer-t;

  if(ignore_nonlin) {
    result[3] = nonlin;
  }

  string indexed_pfd;
  string indexed_factors;

  // write ssi
  write("ssi:w "+to_dir+"result_"+filename+".ssi", result);

  // write as clear text
  if (find(output_format, "cleartext")) {
    write(":w " + to_dir + "result_" + filename + ".txt", pfd_as_txt(result));
  }
  if (find(output_format, "listnumden")) {
    write(":w " + to_dir + "result_" + filename + "_input.txt", pfd_as_txt_input(result));
  }

  // write denominator indexed
  if (find(output_format, "indexed_denominator")) {
    indexed_pfd, indexed_factors = pfd_as_indexed_txt(result);
    write(":w "+to_dir+"result_indexed_denominator_"+filename+".txt", indexed_pfd);
    write(":w "+to_dir+"result_factors_denominator_"+filename+".txt", indexed_factors);
  }

  // write indexed
  if (find(output_format, "indexed_numerator_denominator")) {
  list factorized_numerators_result = factorize_numerators(result);
  indexed_pfd, indexed_factors = pfd_as_indexed_txt(factorized_numerators_result);
  write(":w "+to_dir+"result_indexed_"+filename+".txt", indexed_pfd);
  write(":w "+to_dir+"result_factors_"+filename+".txt", indexed_factors);
  }

  write( ":a "+to_dir+"resources_"+filename+".txt"
       , sprintf( "Time: %s ms,  Memory: %s Bytes with implementation %s"
                , t
                , memory(2)
                , pfd_implementation)
       );
}

proc factorize_numerators(list dec)
{
  int i, j, k;
  ideal q = dec[1];
  list terms = dec[2];
  list term;
  list num_factors;
  intvec indices;
  number ncoeff;
  for (i = 1; i <= size(terms); i++) {
    indices = 0:0;
    term = terms[i];
    num_factors = factorize(term[1]);
    ncoeff = 1;
    // after factorization, the first entry is the coefficient.
    ncoeff = ncoeff * number(num_factors[1][1])^num_factors[2][1];
    for (j = 2; j <= size(num_factors[1]); j++) {
      // collect leadcoefficients in ncoeff
      ncoeff = ncoeff * number(leadcoef(num_factors[1][j]))^num_factors[2][j];
      num_factors[1][j] = num_factors[1][j] / leadcoef(num_factors[1][j]);
      // collect content in ncoeff
      ncoeff = ncoeff * number(content(num_factors[1][j]))^num_factors[2][j];
      num_factors[1][j] = num_factors[1][j] / content(num_factors[1][j]);
    }
    if (size(num_factors[1]) > 1) {
      num_factors[1] = delete(num_factors[1], 1);
      num_factors[2] = delete(num_factors[2], 1);
    } else {
      num_factors[1] = list();
      num_factors[2] = list();
    }

    for (j = 1; j <= size(num_factors[1]); j++) {
      q = q + num_factors[1][j];
      if (q[size(q)] == num_factors[1][j]) {
        indices[j] = size(q);
      } else {
        for (k = 1; k <= size(q); k++) {
          if (q[k] == num_factors[1][j]) {
            indices[j] = k;
            break;
          }
        }
        if (k > size(q)) {
          ERROR("should have found index for factor " +
          string(num_factors[1][j]) + " in " + string(q));
        }
      }
    }
    if (size(indices) != size(num_factors[2])) {
      ERROR("indices and powers should have the same size");
    }
    terms[i] = list(list(ncoeff, indices, num_factors[2]), term[2], term[3]);
  }

  return (list(q, terms));
}


proc parsePfdSingleEntryArgs(list #)
{
  // defaults:
  string from_dir = "";
  string to_dir = "";
  string pfd_implementation = "Leinartas";
  int ignore_nonlin = 0;
  intvec steps = 1,1,1,1;
  int save_int_res = 1;
  int parallelize = 0;
  string input_format = "ssi";
  string output_format = "ssi,cleartext,listnumden,indexed_denominator,indexed_numerator_denominator";

  // user defined
  if (size(#) > 0) {
    from_dir = #[1];
    if (from_dir[size(from_dir)] != "/" && size(from_dir)>0) {
      from_dir = from_dir + "/";
    }
  }

  if(size(#)>1) {
    to_dir = #[2];
    if (to_dir[size(to_dir)] != "/" && size(to_dir) > 0) {
      to_dir = to_dir + "/";
    }
  }

  if (size(#)>2) {
    pfd_implementation = #[3];
    if ((pfd_implementation != "Leinartas") &&
        (pfd_implementation != "MultivariateApart")) {
      ERROR("pfd_implementation should be 'lein' or 'MultivariateApart_kl'");
    }
  }

  if (size(#)>3) {
    ignore_nonlin = #[4];
  }

  if (size(#)>4) {
    steps = #[5];
  }

  if (size(#)>5) {
    save_int_res = #[6];
  }

  if (size(#)>6) {
    parallelize = #[7];
  }

  if (size(#)>7) {
    input_format = #[8];
  }
  if (size(#)>8) {
    output_format = #[9];
  }

  return ( list( from_dir
               , to_dir
               , pfd_implementation
               , ignore_nonlin
               , steps
               , save_int_res
               , parallelize
               , input_format
               , output_format
               )
         );
}

proc nonlin_as_txt(list nonlin)
{
  int i;
  string nonlin_txt = "";
  if (typeof(nonlin) != "list") {
    ERROR("Malformed nonlinears: should be in list");
  }
  if (size(nonlin) == 0) {
    return ("");
  }
  if (typeof(nonlin[1]) != "list") {
    ERROR("Malformed nonlinears: if nonempty, should contain exactly two lists");
  }
  if (size(nonlin[1]) == 0) {
    return ("");
  }
  for (i = 1; i <= size(nonlin[1]); i++) {
    if (i > 1) {
      nonlin_txt = nonlin_txt + "*";
    }
    if (nonlin[2][i] > 1) {
      nonlin_txt = nonlin_txt + "(" + string(nonlin[1][i]) + ")^" + string(nonlin[2][i]);
    } else{if (nonlin[2][i] == 1) {
      nonlin_txt = nonlin_txt + "(" + string(nonlin[1][i]) + ")";
    } else {
      ERROR("Malformed nonlinear factor: power should be positive, got " +
            string(nonlin[2][i]) + " instead");
    }}
  }

  return (nonlin_txt);
}

proc pfd_as_txt(list result)
{
  string dec;
  string nonlin_fact;

  if (size(result) >= 3) {
    list nonlin = result[3];
  } else {
    list nonlin = list(list(), list());
  }

  dec = getStringpfd(result);
  nonlin_fact = nonlin_as_txt(nonlin);
  if (size(nonlin_fact) > 0) {
    dec = "1/(" + nonlin_fact + ") * (" + dec + ")";
  }
  return (dec);
}

proc pfd_as_txt_input(list result, list #)
{
  string dec;
  string nonlin_fact;
  int i;
  int j;
  int factorized_denom;

  if(size(#) > 0) {
    factorized_denom = #[1];
  } else {
    factorized_denom = 1;
  }

  string input_representation = "list( ";

  ideal q = result[1];
  list terms = result[2];
  list term;

  if (size(result) >= 3) {
    list nonlin = result[3];
  } else {
    list nonlin = list(list(), list());
  }

  nonlin_fact = nonlin_as_txt(nonlin);

  string num, denom;
  for (i = 1; i<= size(terms); i++) {
    num = "";
    denom = "";
    if (i > 1) {
      input_representation = input_representation + ", ";
    }
    term = terms[i];
    num = string(term[1]);
    for (j = 1; j <= size(term[2]); j++) {
      if (j > 1) {
        denom = denom + "*";
      }
      denom = denom + "(" + string(q[term[2][j]]) + ")";
      if (term[3][j] != 1) {
        denom = denom + "^" + string(term[3][j]);
      }
    }
    if (size(nonlin_fact) > 0) {
        denom = denom + "*" + nonlin_fact;
    }
    if (!factorized_denom) {
      execute("denom = string(" + denom + ");");
    }
    input_representation = input_representation + "list( " + num + ", " + denom + ")";
  }
  input_representation = input_representation + " )";

  return (input_representation);
}

proc pfd_as_indexed_txt(list result)
{
  int i,j,k;
  string dec;
  string nonlin_fact;

  if (size(result)>= 3) {
    list nonlin = result[3];
  } else {
    list nonlin = list(list(), list());
  }

  k = size(nonlin[1]);

  dec = getStringpfd_indexed(result);
  ideal q = result[1];
  int nq = size(q);
  for (i = 1; i <= size(nonlin[1]); i++) {
    // add to ideal;
    q[nq+i] = nonlin[1][i];
    // replace in nonlin, so we can reuse nonlin_as_txt
    nonlin[1][i] = "q" + string(i + size(q));
  }
  nonlin_fact = nonlin_as_txt(nonlin);
  if(size(nonlin_fact) > 0)
  {
    dec = "1/(" + nonlin_fact + ") * (" + dec + ")";
  }

  string denom_fact;
  for(i=1; i<=size(q); i++)
  {
    denom_fact = denom_fact + "q" + string(i) + " = " + string(q[i]) + "%n";
  }
  denom_fact = sprintf(denom_fact,0);

  return(dec, denom_fact);
}

proc prepareNonLin(list formatted_fraction, int ignore_nonlin)
{
  if (size(formatted_fraction) == 3) {
    // in this case, we assume the nonlinear factors have already been correctly 
    // removed
    return (list(delete(formatted_fraction, 3), formatted_fraction[3]));
  }

  list nonlin = list(list(),list());
  if (ignore_nonlin) {
    int i, j, k, l, lcm;
    i = 1;
    for(k=1; k<=size(formatted_fraction[1]); k++) // over factors
    {
      if(deg(formatted_fraction[1][k])>1) { // identify nonlinear
        // find greatest power of factor.
        lcm = 0;
        for (j = 1; j <= size(formatted_fraction[2]); j++) { // over summands
          for (l = 1; l <= size(formatted_fraction[2][j][2]); l++) { //over indices
            if ((formatted_fraction[2][j][2][l] == k) && // factor in question
                (formatted_fraction[2][j][3][l] > lcm)) { // greater power
              lcm = formatted_fraction[2][j][3][l];
            }
          }
        }

        // multiply each summand with factor^lcm and delete the denominator part 
        for (j = 1; j <= size(formatted_fraction[2]); j++) { // over summands
          // multiply with power lcm
          formatted_fraction[2][j][1] = formatted_fraction[2][j][1] *
                                              (formatted_fraction[1][k]^lcm);

          for (l = 1; l <= size(formatted_fraction[2][j][2]); l++) { //over indices
            if (formatted_fraction[2][j][2][l] == k) { // factor in question
              // divide from numerator the part that is below the line
              formatted_fraction[2][j][1] = formatted_fraction[2][j][1] /
                    (formatted_fraction[1][k]^(formatted_fraction[2][j][3][l]));

              // delete index and power that references to this factor
              formatted_fraction[2][j][2] = delete(formatted_fraction[2][j][2], l);
              formatted_fraction[2][j][3] = delete(formatted_fraction[2][j][3], l);

              // handle fact we deleted entry, so l is now already on next entry
              l--;
            } else{if (formatted_fraction[2][j][2][l] > k) { // one of the larger indices
              // we are deleting factor k from ideal, need to decrement the
              // larger indices to still make sense
              formatted_fraction[2][j][2][l] = formatted_fraction[2][j][2][l] - 1;
            }}
          }
        }

        nonlin[1][i] = formatted_fraction[1][k];
        nonlin[2][i] = lcm;
        formatted_fraction[1] = delete(formatted_fraction[1], k);
        i++;

        // handle index arithmatic, as we deleted k
        k--;
      }
    }
  }
  return (list(formatted_fraction, nonlin));
}

proc checkSingleEntryFraction(list formatted_fraction)
{
  if (typeof(formatted_fraction[1]) != "ideal") {
    ERROR("unknown file format: " + from_dir + filename +
          ".ssi - expected ideal at first index");
    return(0);
  }
  if (typeof(formatted_fraction[2]) != "list") {
    ERROR("unknown file format: " + from_dir + filename +
          ".ssi - expected list at second index");
    return(0);
  }

  number lcoeff, lcontent;
  int k;

  for (k=1; k<=size(formatted_fraction[1]); k++) {
    lcoeff = leadcoef(formatted_fraction[1][k]);
    lcontent = content(poly(formatted_fraction[1][k])/number(lcoeff));
    if (lcoeff * lcontent != 1) {
      ERROR("Lead coefficient not 1");
      return(0);
    }

    if (content(formatted_fraction[1][k]) != 1) {
      ERROR("Lead coefficient not 1");
      return(0);
    }
  }
  return(1);

}

proc process_l_input(list summands)
{
  int i, j, k, count;
  list fraction, factors, fact;
  intvec indices = 0:0;
  intvec powers = 0:0;
  if (!defined(basering)) {
    ERROR("Please set a basering, that matches the variable names used in " +
    input);
  }
  ideal q;
  number constant;

  number lcoeff;
  list lcoeffs;
  list lcontents;

  for (i = 1; i <= size(summands); i++) {
    fraction = summands[i];

    // manage leading coefficient
    fact = factorize(fraction[2]);
    constant = number(fact[1][1])^fact[2][1];
    fact[1] = delete(fact[1], 1);
    fact[2] = delete(fact[2], 1);
    fraction[1] = fraction[1] * (1/constant);

    for (j = 1; j <= size(fact[1]); j++) {
      // fix lead coeff
      lcoeff= number(leadcoef(fact[1][j]));
      fact[1][j] = fact[1][j] * (1/lcoeff);
      fraction[1] = fraction[1] * (1/(lcoeff^fact[2][j]));

      // make integer coefficients
      lcoeff= number(content(fact[1][j]));
      fact[1][j] = fact[1][j] * (1/lcoeff);
      fraction[1] = fraction[1] * (1/(lcoeff^fact[2][j]));

      // add to ideal
      q = q + fact[1][j];
    }

    // reindex
    count = 0;
    indices = 0:0;
    powers = 0:0;
    for (j = 1; j <= size(q); j++) {
      for (k = 1; k <= size(fact[1]); k++) {
        if (q[j] == fact[1][k]) {
          count++;
          indices[count] = j;
          powers[count] = fact[2][k];
        }
      }
    }
    if (size(indices) != size(fact[1])) {
      ERROR("could not find all factors when parsing from string");
    }
    // add back to summands
    summands[i] = list(fraction[1], indices, powers);
  }


  list formatted_fraction = list( q // the ideal
                                , summands // sum of rationals
                                );

  if (!checkSingleEntryFraction(formatted_fraction)) {
    ERROR("bug in sorting out fraction format");
  }

  return (formatted_fraction);
}

proc prepareSingleEntryFraction( string filename
                               , string from_dir
                               )
{
  if (file_exists(from_dir + filename + ".ssi")) {
    list formatted_fraction = read("ssi:r " + from_dir + filename + ".ssi");
    if (checkSingleEntryFraction(formatted_fraction)) {
      // format correct, we are done here.
      return();
    }
    // in this case, the check function will throw and error, should now exit
    // programme.
  } else {
    list summands;
    if (!defined(basering)) {
      ERROR("Please set a basering, that matches the variable names used in " +
      filename);
    }
    string s = read(":r " + from_dir + filename + ".txt");
    execute("summands = " + s + ";");
    list formatted_fraction = process_l_input(summands);
    write("ssi:w "+from_dir+filename+".ssi", formatted_fraction);
  }
}

proc pfdSingleEntrySSI(string filename, list #)
"USAGE:   pfdSingleEntrySSI(filename[,from_dir,to_dir]), filename,from_dir,to_dir string
PURPOSE:  Only creates the input ssi-file as in @ref{pfdSingleEntry} inside the
          directory @code{to_dir} (default: current directory). The input is a
          txt-file as in @ref{pfdSingleEntry} of the given name @{filename}
          inside the directory @code{from_dir} (default: current directory).
          The current basering has to match the variable names used in the input
          file.
          (For the actual pfd calculation use pfdSingleEntry!)
SEE ALSO: pfdMat, pfdSingleEntry
"
{
  system("--ticks-per-sec",1000);
  short = 0;
  if(size(#)>0)
  {
    string from_dir = #[1]; // read file from this
    if(from_dir[size(from_dir)]!="/" && size(from_dir)>0) {from_dir = from_dir + "/";}
  }
  else {string from_dir = "";}
  if(size(#)>1)
  {
    string to_dir = #[2];
    if(to_dir[size(to_dir)]!="/" && size(to_dir)>0) {to_dir = to_dir + "/";}
  }
  else {string to_dir = "";}

  int i,j,k;
  list fraction;
  i = find(filename,".");
  if(i>0) {filename = filename[1,i-1];} // remove file ending if given

  if(!file_exists(to_dir+filename+".ssi"))
  {
    string s = read(":r "+from_dir+filename+".txt");
    if(!defined(basering))
      {ERROR("Please set a basering, that matches the variable names used in "
                                       + "the input file ("+filename+".txt).");}
    string s1,s2;
    j = find(s,"/(");
    if(j==0) // no denominator
    {
      fraction = list(string_to_poly(s), poly(1));
    }
    else
    {
      s1 = s[1,j-1];
      s2 = s[j+1,size(s)-j];
      fraction = list(string_to_poly(s1), string_to_poly(s2));
    }

    list fact = factorize(fraction[2]);

    number lcoeff;
    number constant = number(fact[1][1])^fact[2][1];
    fact[1] = delete(fact[1],1);
    fact[2] = delete(fact[2],1);
    for(k=1; k<=size(fact[1]); k++)
    {
      lcoeff = leadcoef(fact[1][k]);
      fact[1][k] = fact[1][k]/lcoeff;
      constant = constant*(lcoeff^fact[2][k]); // polynomial is monic (thus unique)
      lcoeff = content(fact[1][k]);
      fact[1][k] = fact[1][k]/lcoeff;
      constant = constant*(lcoeff^fact[2][k]); // polynomial has nice coefficients
    }

    fraction[1] = fraction[1] * (1/constant);
    fraction[2] = fact;

    write("ssi:w "+to_dir+filename+".ssi", fraction);
  }
}



/*

// pfd for massive parallel computing with GPI-Space ///////////////////////////

proc initializeSSI(string filename, list #)
"USAGE:   initializeSSI(filename[,from_dir,to_dir]), filename,from_dir,to_dir string
PURPOSE:  Creates an input ssi-file containing the input rational function in the
          format needed for decompStepGPI() inside the directory @code{to_dir}
          (default: current directory). Also creates a ssi-file with a list of all
          denominator factors and removes the nonlinear factors and saves them
          into a separate file. The input is a
          txt-file as in @ref{pfdSingleEntry} of the given name @{filename}
          inside the directory @code{from_dir} (default: current directory).
          The current basering has to match the variable names used in the input
          file.
SEE ALSO:
"
{
  system("--ticks-per-sec",1000);
  short = 0;
  if(size(#)>0)
  {
    string from_dir = #[1]; // read file from this
    if(from_dir[size(from_dir)]!="/" && size(from_dir)>0) {from_dir = from_dir + "/";}
  }
  else {string from_dir = "";}
  if(size(#)>1)
  {
    string to_dir = #[2];
    if(to_dir[size(to_dir)]!="/" && size(to_dir)>0) {to_dir = to_dir + "/";}
  }
  else {string to_dir = "";}

  int i,j,k;
  list fraction;
  i = find(filename,".");
  if(i>0) {filename = filename[1,i-1];} // remove file ending if given

  if(!file_exists(to_dir+filename+".ssi"))
  {
    string s = read(":r "+from_dir+filename+".txt");
    if(!defined(basering))
      {ERROR("Please set a basering, that matches the variable names used in "
                                       + "the input file ("+filename+".txt).");}
    string s1,s2;
    j = find(s,"/(");
    if(j==0) // no denominator
    {
      fraction = list(string_to_poly(s), poly(1));
    }
    else
    {
      s1 = s[1,j-1];
      s2 = s[j+1,size(s)-j];
      fraction = list(string_to_poly(s1), string_to_poly(s2));
    }

    list fact = factorize(fraction[2]);

    number lcoeff;
    number constant = number(fact[1][1])^fact[2][1];
    fact[1] = delete(fact[1],1);
    fact[2] = delete(fact[2],1);
    for(k=1; k<=size(fact[1]); k++)
    {
      lcoeff = leadcoef(fact[1][k]);
      fact[1][k] = fact[1][k]/lcoeff;
      constant = constant*(lcoeff^fact[2][k]); // polynomial is monic (thus unique)
      lcoeff = content(fact[1][k]);
      fact[1][k] = fact[1][k]/lcoeff;
      constant = constant*(lcoeff^fact[2][k]); // polynomial has nice coefficients
    }

    fraction[1] = fraction[1] * (1/constant);
    fraction[2] = fact[1];
    fraction[3] = fact[2];
    fraction[4] = 0;  // fourth entry determines in which phase of the algorithm the term is (0: NSSdecompStep, 1: shortNumeratorDecompStep, ..., 4: finished)

    list nonlin = list(ideal(),intvec(0:0));
    i = 1;
    for(k=1; k<=size(fraction[2]); k++) // move nonlinear factors into nonlin
    {
      if(deg(fraction[2][k])>1)
      {
        nonlin[1][i] = fraction[2][k];
        nonlin[2][i] = fraction[3][k];
        fraction[2] = delete(fraction[2],k);
        fraction[3] = delete(fraction[3],k);
        i++;
      }
    }

    int l1 = size(fraction[2]);
    int l2 = size(nonlin[1])
    ideal q = fraction[2] + nonlin[1]; // ideal of all denominator factors
    if(l1==0) {fraction[2] = intvec(0:0);}
    else {fraction[2] = intvec(1..l1);}
    if(l2==0) {nonlin[1] = intvec(0:0);}
    else {nonlin[1] = intvec((l1+1)..(l1+l2));}

    write("ssi:w "+to_dir+filename+"_denominator_factors.ssi", q); // all denominator factors
    write("ssi:w "+to_dir+filename+"_non_linear_factors.ssi", nonlin); // (indices of) non-linear enominator factors
    write("ssi:w "+to_dir+filename+".ssi", fraction); // rational function in the format needed for decompStepGPI()
  }
}

proc decompStepGPI(string term_file, string denom_fact_file)
{
  list term = read("ssi:r "+term_file);
  ideal q = read("ssi:r "+denom_fact_file);
  int i,j;
  list result, dec1, dec2;
  phase = term[4];   // fourth entry etermines in which phase of the algorithm this term is:
  if(phase==0)
  {
    result = NSSdecompStep(term, q);
    if(size(result)>1)
      {dec1=result;}
    else
      {dec2=result;}
  }
  else{if(phase==1)
  {
    result = shortNumeratorDecompStep(term, q);
    dec1 = result[1];
    dec2 = result[2];
  }
  else{if(phase==2)
  {
    result = algDependDecompStep(term, q);
    if(size(result)>1)
      {dec1=result;}
    else
      {dec2=result;}
  }
  else{if(phase==3)
  {
    result = numeratorDecompStep(term, q);
    dec1 = result[1];
    dec2 = result[2];
  }
  else
  {
    return; // term already finished ==> do nothing
  }}}}

  // now dec2 contains the (0 or 1) terms that finished the current decomposition step
  // and dec1 contains the rest of the decomposition (possibly empty)

  for(i=1; i<=size(dec1); i++)
  {
    dec1[i][4] = phase
    write("ssi:w "+ ???, dec1[i]) // how are new filenames selected?
  }

  for(i=1; i<=size(dec2); i++)
  {
    dec2[i][4] = phase + 1
    write("ssi:w "+ ???, dec2[i]) // how are new filenames selected?
  }
  // Note: Also, the input file ("term_file") must be deleted/overwritten.
}

proc mergeTermsGPI(string l1_file, string l2_file)
{
  list l1 = read("ssi:r " + l_file)
  list l2 = read("ssi:r " + l_file)
  if(elementwise_equality(l1[2],l2[2]) && elementwise_equality(l1[3],l2[3])) // terms have same denominator
  {
    l1[1] = l1[1] + l2[1]; // add numerators
    l1[4] = max(l1[4],l2[4]);
    write("ssi:w " + l1_file, l1); // save merged term in l1_file
    //delete the file "l2_file"    // delete the other term
  }
}

proc createOutputFilesGPI(list input_filenames, string denom_fact_file, string nonlin_fact_file, list #)
"USAGE:   createOutputFilesGPI(input_filenames, denom_fact_file, nonlin_fact_file[,from_dir,to_dir,output_filename]), input_filenames list, denom_fact_file,nonlin_fact_file,from_dir,to_dir,output_filename string
PURPOSE:  collects the terms of the decomposition in a single file.
          input_filenames is a list of names of ssi-files containing one term each.
          denom_fact_file and nonlin_fact_file are the (directory and) filename
          of the files created by initializeSSI, that contain a list of all
          denominator factors and the nonlinear denominator factors respectively.
          @code{from_dir} and @code{to_dir} are the directories (relative to current
          directory) of the input and output files respectively (default:
          current directory).

       @* The result will be safed as 4 txt- and ssi-files:
       @* - the result in indexed and non-indexed form (two .txt-files)
       @* - a list of denominator factors appearing in that rational function (.txt-file)
       @* - the result as .ssi-file containng the direct output of @ref{pfd}
            if @code{ignore_nonlin} is false or a two-element list of the
            nonlinear denominator factors (in factorized form) and the output of
            @ref{pfd} (without nonlinear denominator factors) if
            @code{ignore_nonlin} is true.
SEE ALSO: pfd, pfdParallel, pfdMat, pfdSingleEntrySSI
"
{
  system("--ticks-per-sec",1000);
  short = 0;
  int i,j,k;
  if(size(#)>0)
  {
    string from_dir = #[1]; // read file from this
    if(from_dir[size(from_dir)]!="/" && size(from_dir)>0) {from_dir = from_dir + "/";}
  }
  else {string from_dir = "";}
  if(size(#)>1)
  {
    string to_dir = #[2];
    if(to_dir[size(to_dir)]!="/" && size(to_dir)>0) {to_dir = to_dir + "/";}
  }
  else {string to_dir = "";}
  if(size(#)>2)
  {
    string output_filename = #[3];
    j = find(output_filename[i],".");
    if(j>0) {output_filename[i] = output_filename[i][1,j-1];} // remove file ending if given
  }
  else {output_filename = "result";}

  ideal q = read("ssi:r " + denom_fact_file);
  list nonlin = read("ssi:r " + nonlin_fact_file);
  list result;
  list newterm;
  int nterms = size(input_filenames);
  for(i=1;i<=nterms;i++)
  {
    j = find(input_filenames[i],".");
    if(j>0) {input_filenames[i] = input_filenames[i][1,j-1];} // remove file ending if given
    newterm = read("ssi:r" + from_dir + input_filenames[i]+".ssi");
    results = mergepfd(results, list(newterm));
  }

  // output as Singular object
  write("ssi:w "+to_dir+output_filename+".ssi",result);

  //output as txt:
  string dec;
  string nonlin_fact;
  k = size(nonlin[1]);

  dec = getStringpfd(list(q,result));
  if(k>0)
  {
    nonlin_fact = "";
    for(i=1; i<=k; i++)
    {
      if(nonlin[2][i]>1)
        {nonlin_fact = nonlin_fact + "(" + string(q[nonlin[1][i]]) + ")^" + string(nonlin[2][i]) + "*";}
      else
        {nonlin_fact = nonlin_fact + "(" + string(q[nonlin[1][i]]) + ")*";}
    }
    nonlin_fact = nonlin_fact[1,size(nonlin_fact)-1];
    dec = "1/(" + nonlin_fact + ") * (" + dec + ")";
  }
  write(":w "+to_dir+output_filename+".txt", dec);

  //output as txt (indexed):
  dec = getStringpfd_indexed(list(q,result));
  if(k>0)
  {
    nonlin_fact = "";
    for(i=1; i<=k; i++)
    {
      if(nonlin[2][i]>1)
        {nonlin_fact = nonlin_fact + "q" + string(nonlin[1][i]) + "^" + string(nonlin[2][i]) + "*";}
      else
        {nonlin_fact = nonlin_fact + "q" + string(nonlin[1][i]) + "*";}
    }
    nonlin_fact = nonlin_fact[1,size(nonlin_fact)-1];
    dec = "1/(" + nonlin_fact + ") * (" + dec + ")";
  }
  write(":w "+to_dir+output_filename+"_indexed.txt", dec);

  // list of denominator factors
  string denom_fact;
  for(i=1; i<=size(q); i++)
  {
    denom_fact = denom_fact + "q" + string(i) + " = " + string(q[i]) + "%n";
  }
  fprintf(":w "+to_dir+output_filename+"_denominator_factors.txt", denom_fact,0);
}


// alternatively: use 4 different functions for the decomposition: /////////////

static proc NSSdecompStepGPI(string l_file, string q_file)
{
  list l = read("ssi:r " + l_file)
  ideal q = read("ssi:r " + q_file)
  if(l[4] != 0)  // term has not reached this step yet or has already finished it ==> do nothing
  {
    write("ssi:w " + ..., l);
    return;
  }

  poly f=l[1];
  intvec indices=l[2];
  intvec e=l[3];
  int m = size(indices);

  if(m==0) // denominator is 1
  {
    l[4] = 4;
    write("ssi:w " + ..., l);
    return;
  }

  ideal qe = q[indices];
  for(int i=1; i<=m; i++)
    {qe[i] = qe[i]^e[i];}
  matrix T;
  ideal qe_std = liftstd(qe,T);

  if(deg(qe_std) == 0)
  {
    T = T/qe_std[1];
      // now 1 = T[1,1]*qe[1] + ... + T[m,1]*qe[m] is a Nullstellensatz certificate
    list dec;
    poly h;
    for(i=1; i<=m; i++)
    {
      h = T[i,1];
      if(h != 0)
        {dec[size(dec)+1] = list(f*h,delete(indices,i),delete(e,i));}
    }
    for(int i=1; i<=size(dec); i++)
    {
      dec[i][4]=0;
      write("ssi:w " + ..., dec[i]);
    }
    return;
  }
  else
  {
    l[4] = 1;
    write("ssi:w " + ..., l);
    return;
  }
}

static proc shortNumeratorDecompStepGPI(string l_file, string q_file, list #)
{
  list l = read("ssi:r " + l_file)
  ideal q = read("ssi:r " + q_file)
  if(l[4] != 1)  // term has not reached this step yet or has already finished it ==> do nothing
  {
    write("ssi:w " + ..., l);
    return;
  }

  int debug=0;
  if(size(#)>0) {debug=#[1]; link ll=#[2];}
  if(debug) {system("--ticks-per-sec",1000); int tt=rtimer;}

  poly f=l[1];
  intvec indices=l[2];
  intvec e=l[3];
  int m = size(indices);

  if(m==0) // denominator is 1
  {
    if(debug)
      {fprintf(ll,"      shortNumeratorDecompStep: %s ms (m=%s, e=%s) "
                    +"--> constant denominator", rtimer-tt, m, e);}
    l[4] = 4;
    write("ssi:w " + ..., l);
    return;
  }

  ideal q_denom = q[indices]; // factors occuring in the denominator
  matrix T;
  ideal q_std = liftstd(q_denom,T);
  list divrem = division(f,q_std);
  poly r = divrem[2][1]/divrem[3][1,1];

  if(r!=0)
  {
    if(debug)
      {fprintf(ll,"      shortNumeratorDecompStep: %s ms (m=%s, e=%s) "
                  +"--> remainder is nonzero", rtimer-tt, m, e);}
    l[4] = 2
    write("ssi:w " + ..., l);
    return;              // if there is a rest, decomposing further would
  }                      // not help in the next step (alg. depend. decomposition)

  matrix a = divrem[1]/divrem[3][1,1]; // now f = r + a[1,1]*q_std[1] + ... +a[m,1]*q_std[m]
  a = T*a;   // lift coefficients   ==>   now f = r + a[1,1]*q[1]     + ... +a[m,1]*q[m]

  // reduce w.r.t. groebner basis of syz(q) to make the numerators "smaller":
  vector v;
  for(int i=1; i<=m; i++) {v = v + gen(i)*a[i,1];}
  v = reduce(v, std(syz(q_denom)));

  list fraction,dec;
  for(i=1; i<=m; i++)
  {
    if(v[i] == 0)
    {
      i++;
      continue;
    }
    fraction[1] = v[i];
    if(e[i]==1)
      {
        fraction[2] = delete(indices,i);
        fraction[3] = delete(e,i);
      }
    else
    {
      fraction[2] = indices;
      fraction[3] = e;
      fraction[3][i] = fraction[3][i] - 1;
    }
    dec[size(dec)+1] = fraction;
  }

  if(debug)
    {fprintf(ll,"      shortNumeratorDecompStep: %s ms (m=%s, e=%s, deg(v)=%s, size(v)=%s)",
     rtimer-tt, m, e, deg(v), size(v));}

  for(i=1; i<=size(dec); i++)
  {
   dec[i][4]=1;
   write("ssi:w " + ..., dec[i]);
  }
}

static proc algDependDecompStepGPI(string l_file, string q_file, list #)
{
  list l = read("ssi:r " + l_file)
  ideal q = read("ssi:r " + q_file)
  if(l[4] != 2)  // term has not reached this step yet or has already finished it ==> do nothing
  {
    write("ssi:w " + ..., l);
    return;
  }

  int debug=0;
  if(size(#)>0) {debug=#[1]; link ll=#[2];}
  if(debug) {system("--ticks-per-sec",1000); int tt=rtimer;}
  def br = basering;
  int d = nvars(br);
  intvec indices=l[2];
  int m = size(indices);
  intvec e=l[3];
  int i;

  if(m==0) // denominator is 1
  {
    if(debug)
      {fprintf(ll,"      algDependDecompStep: %s ms (m=%s, e=%s)", rtimer-tt, m, e);}
    l[4] = 4;
    write("ssi:w " + ..., l);
    return; // do nothing, return input
  }

  if(m<=d)
  {
    if(size(syz(module(transpose(jacob(ideal(q[indices]))))))==0) // jacobian criterion
    {
      if(debug)
        {fprintf(ll,"      algDependDecompStep: %s ms (m=%s, e=%s) "
                    +"--> alg. indep.", rtimer-tt, m, e);}
      l[4] = 3;
      write("ssi:w " + ..., l);
      return; // do nothing, return input
    }
  }
  //printf("%nq=%s",q);
  //printf("indices=%s",indices);

  def R = changeord(list(list("dp",m+d)),extendring(m, "y(", "dp", 1, changevar("x()",br)));
  setring(R);

  list l = fetch(br,l);
  ideal q = fetch(br,q);
  poly f=l[1];

  ideal I;
  for(i=1; i<=m; i++)
    {I[i] = y(i)-q[indices[i]];}

  ideal annihilatingPolys = eliminate(I,intvec(1..d));

  poly g = annihilatingPolys[1];

  poly tail = g[size(g)];    // term of lowest dp-order (thus lowest degree)
  //printf("tail: %s",tail);
  number tcoeff = leadcoef(tail);
  intvec texpon = leadexp(tail);
  texpon = texpon[(d+1)..(d+m)];
  g = g-tail;
  poly term;
  number coeff;
  intvec expon;
  list fraction,dec;
  int pow;
  int jmax = size(g);
  for(int j=1; j<=jmax; j++)
  {
    term = g[j];
    coeff = leadcoef(term);
    expon = leadexp(term);
    expon = expon[(d+1)..(d+m)];
    fraction[1] = -f*coeff/tcoeff;
    fraction[2] = intvec(0:0);
    fraction[3] = intvec(0:0);
    for(i=1; i<=m; i++)
    {
      pow = expon[i]-texpon[i]-e[i];
      if(pow>=0)
      {
        fraction[1] = fraction[1]*q[indices[i]]^pow;
      }
      else
      {
        fraction[2][size(fraction[2])+1] = indices[i];
        fraction[3][size(fraction[3])+1] = -pow;
      }
    }
    dec[size(dec)+1] = fraction;
  }
  setring(br);
  list dec = fetch(R,dec);
  if(debug)
    {fprintf(ll,"      algDependDecompStep: %s ms (m=%s, e=%s)", rtimer-tt, m, e);}

  for(i=1; i<=size(dec); i++)
  {
   dec[i][4]=2;
   write("ssi:w " + ..., dec[i]);
  }
}

static proc numeratorDecompStepGPI(string l_file, string q_file, list #)
{
  list l = read("ssi:r " + l_file)
  ideal q = read("ssi:r " + q_file)
  if(l[4] != 3)  // term has not reached this step yet or has already finished it ==> do nothing
  {
    write("ssi:w " + ..., l);
    return;
  }

  int debug=0;
  if(size(#)>0) {debug=#[1]; link ll=#[2];}
  if(debug) {system("--ticks-per-sec",1000); int tt=rtimer;}

  poly f=l[1];
  intvec indices=l[2];
  intvec e=l[3];
  int m = size(indices);

  if(m==0) // denominator is 1
  {
    if(debug)
      {fprintf(ll,"      numeratorDecompStep: %s ms (m=%s, e=%s) "
                  +"--> constant denominator", rtimer-tt, m, e);}
    l[4] = 4;
    write("ssi:w " + ..., l);
    return; // do nothing, return input
  }

  ideal q_denom = q[indices]; // factors in the denominator
  matrix T;
  ideal q_std = liftstd(q_denom,T);
  list divrem = division(f,q_std);
  matrix a = divrem[1]/divrem[3][1,1];
  poly r = divrem[2][1]/divrem[3][1,1]; // now f = r + a[1,1]*q_std[1] + ... +a[m,1]*q_std[m]
  a = T*a;   // lift coefficients    ==>   now f = r + a[1,1]*q[1]     + ... +a[m,1]*q[m]

  // reduce w.r.t. groebner basis of syz(q) to make the numerators "smaller"
  vector v;
  int i;
  for(i=1; i<=m; i++) {v = v + gen(i)*a[i,1];}
  v = reduce(v, std(syz(q_denom)));
  //printf("%nv=%s",v);
  //printf("num=%s",f);
  //printf("den=q[%s] ^ %s",indices,e);
  //printf("remainder=%s",r);
  list fraction,dec,rest;
  if(r!=0)
    {
      write("ssi:w " + ..., list(r,indices,e,4));
    }
  for(i=1; i<=m; i++)
  {
    if(v[i] == 0)
    {
      i++;
      continue;
    }
    fraction[1] = v[i];
    if(e[i]==1)
      {
        fraction[2] = delete(indices,i);
        fraction[3] = delete(e,i);
      }
    else
    {
      fraction[2] = indices;
      fraction[3] = e;
      fraction[3][i] = fraction[3][i] - 1;
    }
    dec[size(dec)+1] = fraction;
  }

  if(debug)
    {fprintf(ll,"      numeratorDecompStep: %s ms (m=%s, e=%s, deg(v)=%s, size(v)=%s)",
     rtimer-tt, m, e, deg(v), size(v));}

  for(i=1; i<=size(dec); i++)
  {
   dec[i][4]=3;
   write("ssi:w " + ..., dec[i]);
  }
}

*/

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//     ALTERNATIVE DECOMPOSITION ALGORITHM                                    //
//     from "MultivariateApart: Generalized Partial Fractions"                //
//     by Matthias Heller, Andreas von Manteuffel                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

proc MultivariateApart_kl(list #)
"USAGE:   MultivariateApart_kl(f,g[,iterated_reduction,debug]);   f,g poly, iterated_reduction,debug int
          MultivariateApart_kl(f,g[,iterated_reduction,debug]);   f poly, g list, iterated_reduction,debug int
          MultivariateApart_kl(arguments[, parallelize]);     arguments list, parallelize int
RETURN:   a partial fraction decomposition of f/g. Can be use like @ref{leinartas_adapted},
          but uses a different decomposition algorithm as described in the paper
          \"MultivariateApart: Generalized Partial Fractions\" by M. Heller,
          A. von Manteuffel.
          Input and output formats identical to @ref{leinartas_adapted}, but there is an
          additional (optional) boolean argument @code{iterated_reduction}
          (default: true), that determines if iterated reductions are used (cf.
          Aglorithm 4 in the paper).
NOTE:     Other than with @code{leinartas_adapted} the result does not depend on the monomial
          ordering.
SEE ALSO: leinartas_adapted, checkpfd, evaluatepfd, displaypfd, displaypfd_long, pfdMat
EXAMPLE:  example MultivariateApart_kl; shows an example"
{
  short = 0;
  int i,j,k,t1,t2,t3,t4,t5,t6,tt;

  int mode=0; // 0: single rational function input, 1: multiple terms
  if(size(#)>1)
  {
    if(typeof(#[1])=="ideal" && typeof(#[2])=="list") {# = list(#); mode=1;}
    if(typeof(#[1])=="list")
      {if(size(#[1])==2)
        {if(typeof(#[1][1])=="ideal" && typeof(#[1][2])=="list") {mode=1;} }}
  }
  if(mode==1) // input of form leinartas_adapted(list(q,terms)[,iterated_reduction,debug])
  {
    int debug=0; link l=":w ";
    if(size(#)>3) {ERROR("wrong number of arguments, expected 1 or 2");}
    if(size(#)==3)
    {
      debug=#[3];
      l=":a "+string(debug)+"_log_"+datetime()+".txt";
      system("--ticks-per-sec",1000);
    }
    if(debug)
    {
      fprintf(l,"debug: %s", debug);
      int counter,tt,ttt;
      t1=0;
    }
    int iterated_reduction = 1;
    if(size(#)>=2)
    {
      iterated_reduction = #[2];
    }

    ideal q = #[1][1];
    list terms = mergepfd(list(), #[1][2]);
    int m = size(q);

    if(size(terms)==1 && terms[1][1]==0) // just one term and its numerator is 0
    {
      list dec = list(ideal(),list(list(poly(0),intvec(0:0),intvec(0:0))));
      if(debug)
        {fprintf(l,"%ntotal: 0 ms (numerator was 0)",0); close(l);}
      if(voice<=printlevel) {displaypfd(dec);}
      return(dec);
    }
  }
  else
  {
    if(typeof(#[1])=="list")
    {
      if(size(#)>1)
      {
        if(typeof(#[2])=="list")
          {list arguments = #;    int parallelize = 1;}
        else{if(typeof(#[2])=="int")
          {list arguments = #[1]; int parallelize = #[2];}
        else {ERROR("wrong type for second argument, expected int");}}
      }
      else // #=list(list(..))
      {
        return(list(MultivariateApart_kl(#[1])));
      }
      if(parallelize)
      {
        for(i=1; i<=size(arguments); i++)
        {
          if(typeof(arguments[i][1])=="list") //input is list of lists
            {arguments[i] = list(arguments[i],1);}
        }
        return(parallelWaitAll("MultivariateApart",arguments));
      }
      else
      {
        list results;
        for(i=1; i<=size(arguments); i++)
        {
          if(typeof(arguments[i][1])=="list") //input is list of lists
            {results[i] = MultivariateApart_kl(arguments[i],0);}
          else
          {
            if(size(arguments[i])==2)
              {results[i] = MultivariateApart_kl(arguments[i][1],arguments[i][2]);}
            else{if(size(arguments[i])==3)
              {results[i] = MultivariateApart_kl(arguments[i][1],arguments[i][2],arguments[i][3]);}
            else{if(size(arguments[i])==4)
              {results[i] = MultivariateApart_kl(arguments[i][1],arguments[i][2],arguments[i][3],arguments[i][4]);}
            else {ERROR("wrong number of arguments, expected 2, 3 or 4");}}}
          }
        }
        return(results);
      }
    }
    poly f = #[1];
    if(typeof(#[2])=="list")
    {
      list g=#[2];
    }
    else
    {
      poly g=#[2];
    }

    int iterated_reduction=1;
    if(size(#)>2) {iterated_reduction=#[3];}

    int debug=0; link l=":w ";
    if(size(#)>4) {ERROR("wrong number of arguments, expected 2,3 or 4");}
    if(size(#)==4)
    {
      debug=#[4];
      l=":a "+string(debug)+"_log_"+datetime()+".txt";
      system("--ticks-per-sec",1000);
    }
    if(debug)
    {
      fprintf(l,"debug: %s", debug);
      fprintf(l,"size(string(f)) = %s, size(string(g)) = %s %n",
                 size(string(f)), size(string(g)), 0);
    }

    if(f==0)
    {
      list dec = list(ideal(),list(list(poly(0),intvec(0:0),intvec(0:0))));
      if(debug)
        {fprintf(l,"%ntotal: 0 ms (numerator was 0)",0); close(l);}
      if(voice<=printlevel) {displaypfd(dec);}
      return(dec);
    }
    if(typeof(g)=="poly")
    {
      if(deg(g)==0)
      {
        list dec = list(ideal(),list(list(f/g,intvec(0:0),intvec(0:0))));
        if(debug)
          {fprintf(l,"%ntotal: 0 ms (denominator was constant)",0); close(l);}
        if(voice<=printlevel) {displaypfd(dec);}
        return(dec);
      }

      // (1) factorization of the denominator ////////////////////////////////////
      if(debug) {t1 = rtimer; write(l,"factorizing ");}
      list factor = factorize(g);
      number lcoeff;
      for(i=2; i<=size(factor[1]); i++)
      {
        lcoeff = leadcoef(factor[1][i]);
        factor[1][i] = factor[1][i]/lcoeff;
        factor[1][1] = factor[1][1]*(lcoeff^factor[2][i]); // polynomial is monic (thus unique)
        lcoeff = content(factor[1][i]);
        factor[1][i] = factor[1][i]/lcoeff;
        factor[1][1] = factor[1][1]*(lcoeff^factor[2][i]); // polynomial has nice coefficients
      }
      ideal q = factor[1];
      f = f/q[1];
      q=delete(q,1);
      intvec e = factor[2]; e=delete(e,1);
      int m = size(q);
      if(debug) {t1 = rtimer-t1; fprintf(l,"done! (%s ms)", t1);}
    }
    else{if(typeof(g)=="list")
    {
      if(size(g[1])==0)
      {
        list dec = list(ideal(),list(list(f,intvec(0:0),intvec(0:0))));
        if(debug)
          {fprintf(l,"%ntotal: 0 ms (denominator was constant)",0); close(l);}
        if(voice<=printlevel) {displaypfd(dec);}
        return(dec);
      }

      // denominator is already factorized
      for(i=1;i<=size(g[1]);i++)
      {
        if(size(factorize(g[1][i])[1])>2)
          {ERROR("factors should be irreducible");}
      }

      ideal q = g[1];
      intvec e = g[2];
      int m = size(q);
    }
    else
    {ERROR("wrong type for second argument, expected poly or list(ideal,intvec)");}}

  }

  // now defined:  f (numerator polynomial), q (denom. factors),
  //               e (denom. exponents), m (size of q,e), debug (true/false)

  // (2) constructing new ring /////////////////////////////////////////////////
  if(debug) {t2 = rtimer; write(l,"constructing new ring ");}
  // group by sets of variables the denominators depend on:
  list groups = list(list(1));
  int ngroups;
  ideal vars1,vars2;
  int is_bigger;
  for(i=2;i<=m;i++)
  {
    ngroups = size(groups);
    vars1 = variables(q[i]);
    for(j=1;j<=ngroups;j++) // insert i (standing for the i-th factor q[i]) into the list groups
    {
      vars2 = variables(q[groups[j][1]]);

      if(size(vars1)>size(vars2)) {is_bigger=1;}
      else{if(size(vars1)<size(vars2)) {is_bigger=0;}
      else
      {
        //print(2001);
        for(k=1;k<=size(vars1);k++)
        {
          //print(2002);
          if(vars1[k]>vars2[k]) {is_bigger=1; break;}
          if(vars1[k]<vars2[k]) {is_bigger=0; break;}
        }
        //print(2003);
        if(k==size(vars1)+1) // vars1 == vars2 ==> insert i in groups[j]
        {
          //print(2004);
          for(k=1;k<=size(groups[j]);k++)
          {
            //print(2005);
            if(deg(q[i])>deg(q[groups[j][k]]))
            {
              //print(2006);
              groups[j] = insert(groups[j],i,k-1);
              break;
            }
          }
          //print(2007);
          if(k==size(groups[j])+1)
          {
            //print(2008);
            groups[j][k] = i;
          }
          //print(2009);
          break;
        }
        //print(20010);
      }}
      if(is_bigger) // new set of variables found ==> insert new group in correct position (degree-lexicographically)
      {
        groups = insert(groups,list(i),j-1);
        break;
      }
    }
    if(j==ngroups+1)
    {
      groups[j] = list(i);
    }
  }
  list var_order = sum(groups);
  // construct ring:
  def r = basering;
  list rlist = ringlist(r);
  // variables:
  rlist[2] = list();
  for(i=1;i<=m;i++)
  {
    rlist[2][i] = "q(" + string(var_order[i]) + ")";
  }
  for(i=1;i<=nvars(r);i++)
  {
    rlist[2][m+i] = "x(" + string(i) + ")";
  }
  // ordering:
  rlist[3] = list();
  for(i=1;i<=size(groups);i++)
  {
    rlist[3][i] = list("dp",intvec(1:size(groups[i])));
  }
  rlist[3][i] = list("dp",intvec(1:nvars(r)));
  rlist[3][i+1] = list("C",intvec(0));
  ring R = ring(rlist);
  setring(R);

  // map everything to the new ring:
  ideal var_ideal;
  for(i=1;i<=nvars(r);i++) {var_ideal[i] = x(i);}
  map phi = r,var_ideal;
  ideal q = phi(q); // denominator factors
  if(mode==1)
  {
    list terms = phi(terms); // representation of the numerators (+ denominator indices and exponents) of the rational function in the new ring
  }
  else
  {
    poly f = phi(f); // representation of the (numerator of the) rational function in the new ring
  }

  // construct the ideal I:
  ideal I;
  for(i=1;i<=m;i++) {I[i] = q(i)*q[i]-1;}
  if(debug) {t2 = rtimer-t2; fprintf(l,"done! (%s ms)", t2);}

  // (3) calculate Groebner basis of I /////////////////////////////////////////
  if(debug) {t3 = rtimer; write(l,"computing Groebner basis");}
  ideal GB = std(I);
  if(debug) {t3 = rtimer-t3; fprintf(l,"done! (%s ms)", t3);}

  // (4) reduce by Groebner basis //////////////////////////////////////////////
  if(iterated_reduction)
  {
    if(debug) {t4=0; t5 = rtimer; write(l,"reducing by Groebner basis (iterated reduction)"); tt = rtimer;}
    if(mode==1)
    {
      poly f = 0;
      poly term;
      for(i=1;i<=size(terms);i++)
      {
        term = terms[i][1];
        for(j=1;j<=size(terms[i][2]);j++)
        {
          term = term*q(terms[i][2][j])^terms[i][3][j];
          term = reduce(term,GB);
        }
        f = f + term;
        if(debug) {fprintf(l,"  term %s out of %s: %s ms", i, size(terms), rtimer-tt); tt=rtimer;}
      }
    }
    else
    {
      for(i=1;i<=m;i++)
      {
        f = f*q(i)^e[i]; // add the i-th "denominator" factor
        f = reduce(f,GB);
        if(debug) {fprintf(l,"  iteration %s out of %s: %s ms", i, m, rtimer-tt); tt=rtimer;}
      }
    }
    if(debug) {t5 = rtimer-t5; fprintf(l,"done! (%s ms)", t5);}
  }
  else
  {
    if(debug) {int t4 = rtimer; write(l,"  representing input rational function(s) as one polynomial");}
    if(mode==1)
    {
      poly f = 0;
      poly term;
      for(i=1;i<=size(terms);i++)
      {
        term = terms[i][1];
        for(j=1;j<=size(terms[i][2]);j++)
        {
          term = term*q(terms[i][2][j])^terms[i][3][j];
        }
        f = f + term;
      }
    }
    else
    {
      for(i=1;i<=m;i++)
      {
        f = f*q(i)^e[i]; // add the i-th "denominator" factor
      }
    }
    if(debug) {t4 = rtimer-t4; fprintf(l,"done! (%s ms)", t1);
               t5 = rtimer; write(l,"reducing by Groebner basis");}
    f = reduce(f,GB);
    if(debug) {t5 = rtimer-t5; fprintf(l,"done! (%s ms)", t5);}
  }

  // (5) translate back to original basering ///////////////////////////////////
  if(debug)
  {
    t6 = rtimer; tt = t6;
    write(l,"formating output");
    write(l,"  constructing list of terms");
  }
  if(0) // alternative code (without creating a new ring, usually slower)
  {
    list dec,sorted;
    intvec lexp,indices,exponents,prev_indices,prev_exponents;
    prev_indices[1] = -1;
    prev_exponents[1] = -1;
    for(i=1;i<=size(f);i++)
    {
      lexp = leadexp(f[i]);
      indices = 0:0;
      exponents = 0:0;
      k = 1;
      for(j=1;j<=m;j++)
      {
        if(lexp[j]>0)
        {
          indices[k] = var_order[j];
          exponents[k] = lexp[j];
          k++;
        }
      }
      if(size(indices>0))
      {
        sorted = sort(indices);
        indices = sorted[1];
        exponents = intvec(exponents[sorted[2]]);
      }
      if(m==1) {lexp[1]=0;}
      else {lexp[1..m] = 0:m;}

      if(indices==prev_indices && exponents == prev_exponents)
        {dec[size(dec)][1] = dec[size(dec)][1] + leadcoef(f[i])*monomial(lexp);}
      else
        {dec[size(dec)+1] = list(leadcoef(f[i])*monomial(lexp),indices,exponents);}
      prev_indices = indices;
      prev_exponents = exponents;
    }
  }

  if(1)
  {
    if(debug)
      {fprintf(l,"    %s ms: creating new ring",rtimer-tt);}
    list rlist = ringlist(R);
    list tmp;
    tmp = rlist[2];
    rlist[1] = list(rlist[1],list(tmp[m+1..m+nvars(r)]),list(list("dp",intvec(1:nvars(r))),list("C",intvec(0))),rlist[4]);
    rlist[2] = list(tmp[1..m]);
    rlist[3] = delete(rlist[3],size(rlist[3])-1);
    ring S = ring(rlist);   // R=K[x,q], S=K(x)[q]
    setring(S);
    if(debug)
      {fprintf(l,"    %s ms: converting to new ring",rtimer-tt);}
    poly f = imap(R,f);
    list dec,sorted;
    intvec lexp,indices,exponents;
    poly term;
    if(debug)
      {fprintf(l,"    %s ms: starting for loop over terms",rtimer-tt);}
    for(i=1;i<=size(f);i++)
    {
      term = f[i];
      lexp = leadexp(term);
      indices = 0:0;
      exponents = 0:0;
      k = 1;
      for(j=1;j<=m;j++)
      {
        if(lexp[j]>0)
        {
          indices[k] = var_order[j];
          exponents[k] = lexp[j];
          k++;
        }
      }
      if(size(indices>0))
      {
        sorted = sort(indices);
        indices = sorted[1];
        exponents = intvec(exponents[sorted[2]]);
      }
      dec[i] = list(leadcoef(term),indices,exponents);
    }
    if(debug)
      {fprintf(l,"    %s ms: converting back",rtimer-tt);}
    setring(R);
    list dec = imap(S,dec);
  }

  if(debug)
    {fprintf(l,"  done! (%s ms)",rtimer-tt); tt = rtimer; write(l,"  sorting terms (mergepfd)");}
  dec = mergepfd(list(),dec);
  if(size(dec)==1) {if(dec[1][1]==0) {dec = list();}}

  if(debug)
    {fprintf(l,"  done! (%s ms)",rtimer-tt); tt = rtimer; write(l,"  mapping to original basering");}
  setring(r);
  ideal var_ideal;
  for(i=1;i<=nvars(r);i++) {var_ideal[m+i] = var(i);}
  map phi = R,var_ideal;
  list dec = q,phi(dec);
  if(debug)
  {
    fprintf(l,"  done! (%s ms)",rtimer-tt);
    t6 = rtimer-t6;
    fprintf(l,"done! (%s ms)", t6);
    fprintf(l,"%ntotal: %s ms", t1+t2+t3+t4+t5+t6);
    close(l);
  }

  if(voice<=printlevel) {displaypfd(dec);}
  return(dec);
}
example
{
  "EXAMPLE:";
  echo=voice;
  ring R = 0,(x,y),dp;
  poly f = x^3+3*x^2*y+2*y^2-x^2+4*x*y;
  poly g = x^2*y*(x-1)*(x-y)^2;

  list dec = MultivariateApart_kl(f,g);

  displaypfd_long(dec);   // display result
  checkpfd(list(f,g),dec);   // check for equality to f/g

  // calculate decompositions of a 2x2 matrix of rational functions at once:
  list arguments = list(list(f, g),          list(1, f)     ),
                        list(list(x*y, y+1), list(1, x^2-y^2));

  dec = MultivariateApart_kl(arguments);

  // the result has the same shape as the
  // input (2x2 matrix as list of lists):
  displaypfd_long(dec[1][1]);
  displaypfd_long(dec[1][2]);
  displaypfd_long(dec[2][1]);
  displaypfd_long(dec[2][2]);

  // a more complicated example
  ring S = 0,(s12,s15,s23,s34,s45),dp;
  poly f = 7*s12^4*s15^2 + 11*s12^3*s15^3 + 4*s12^2*s15^4 - 10*s12^4*s15*s23
    - 14*s12^3*s15^2*s23 - 4*s12^2*s15^3*s23 + 3*s12^4*s23^2 + 3*s12^3*s15*s23^2
    + 13*s12^4*s15*s34 + 12*s12^3*s15^2*s34 + 2*s12^2*s15^3*s34
    - 5*s12^4*s23*s34 + 33*s12^3*s15*s23*s34 + 49*s12^2*s15^2*s23*s34
    + 17*s12*s15^3*s23*s34 - 17*s12^3*s23^2*s34 - 19*s12^2*s15*s23^2*s34
    - 5*s12*s15^2*s23^2*s34 - 24*s12^3*s15*s34^2 - 15*s12^2*s15^2*s34^2
    + 2*s12*s15^3*s34^2 + 15*s12^3*s23*s34^2 - 34*s12^2*s15*s23*s34^2
    - 31*s12*s15^2*s23*s34^2 + 2*s15^3*s23*s34^2 + 33*s12^2*s23^2*s34^2
    + 29*s12*s15*s23^2*s34^2 + 5*s15^2*s23^2*s34^2 + 9*s12^2*s15*s34^3
    - 4*s12*s15^2*s34^3 - 15*s12^2*s23*s34^3 + 9*s12*s15*s23*s34^3
    - 4*s15^2*s23*s34^3 - 27*s12*s23^2*s34^3 - 13*s15*s23^2*s34^3
    + 2*s12*s15*s34^4 + 5*s12*s23*s34^4 + 2*s15*s23*s34^4 + 8*s23^2*s34^4
    - 6*s12^3*s15^2*s45 - 9*s12^2*s15^3*s45 - 2*s12*s15^4*s45
    + 30*s12^3*s15*s23*s45 + 56*s12^2*s15^2*s23*s45 + 24*s12*s15^3*s23*s45
    - 12*s12^3*s23^2*s45 - 23*s12^2*s15*s23^2*s45 - 10*s12*s15^2*s23^2*s45
    - 30*s12^3*s15*s34*s45 - 32*s12^2*s15^2*s34*s45 - 6*s12*s15^3*s34*s45
    + 7*s12^3*s23*s34*s45 - 86*s12^2*s15*s23*s34*s45 - 104*s12*s15^2*s23*s34*s45
    - 15*s15^3*s23*s34*s45 + 41*s12^2*s23^2*s34*s45 + 51*s12*s15*s23^2*s34*s45
    + 10*s15^2*s23^2*s34*s45 - 5*s12^3*s34^2*s45 + 33*s12^2*s15*s34^2*s45
    + 14*s12*s15^2*s34^2*s45 - 2*s15^3*s34^2*s45 - 21*s12^2*s23*s34^2*s45
    + 62*s12*s15*s23*s34^2*s45 + 28*s15^2*s23*s34^2*s45 - 46*s12*s23^2*s34^2*s45
    - 28*s15*s23^2*s34^2*s45 + 10*s12^2*s34^3*s45 - s12*s15*s34^3*s45
    + 4*s15^2*s34^3*s45 + 21*s12*s23*s34^3*s45 - 6*s15*s23*s34^3*s45
    + 17*s23^2*s34^3*s45 - 5*s12*s34^4*s45 - 2*s15*s34^4*s45 - 7*s23*s34^4*s45
    - 6*s12^2*s15^2*s45^2 - 5*s12*s15^3*s45^2 - 2*s15^4*s45^2
    - 28*s12^2*s15*s23*s45^2 - 42*s12*s15^2*s23*s45^2 - 10*s15^3*s23*s45^2
    + 9*s12^2*s23^2*s45^2 + 10*s12*s15*s23^2*s45^2 + 24*s12^2*s15*s34*s45^2
    + 36*s12*s15^2*s34*s45^2 + 10*s15^3*s34*s45^2 - 11*s12^2*s23*s34*s45^2
    + 31*s12*s15*s23*s34*s45^2 + 25*s15^2*s23*s34*s45^2
    - 18*s12*s23^2*s34*s45^2 - 10*s15*s23^2*s34*s45^2 + 4*s12^2*s34^2*s45^2
    - 29*s12*s15*s34^2*s45^2 - 17*s15^2*s34^2*s45^2 + 27*s12*s23*s34^2*s45^2
    + 2*s15*s23*s34^2*s45^2 + 9*s23^2*s34^2*s45^2 - 3*s12*s34^3*s45^2
    + 10*s15*s34^3*s45^2 - 16*s23*s34^3*s45^2 - s34^4*s45^2 + 6*s12*s15^2*s45^3
    + 3*s15^3*s45^3 + 8*s12*s15*s23*s45^3 + 10*s15^2*s23*s45^3
    - 8*s12*s15*s34*s45^3 - 10*s15^2*s34*s45^3 + 9*s12*s23*s34*s45^3
    + s12*s34^2*s45^3 + 8*s15*s34^2*s45^3 - 9*s23*s34^2*s45^3 - s34^3*s45^3
    - s15^2*s45^4 + s15*s34*s45^4;
  poly g = 4*s12*s15*(s12 + s15 - s34)*(s15 - s23 - s34)*(s12 + s23 - s45)
                                 *(s12 - s34 - s45)*(s12 + s15 - s34 - s45)*s45;

  list dec = MultivariateApart_kl(f,g);

  displaypfd(dec);
  checkpfd(list(f,g),dec);

  // size comparison:
  size(string(f)) + size(string(g));
  size(getStringpfd(dec));
}
